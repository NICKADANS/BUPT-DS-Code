# 数据结构(应用题及代码)

## 第2章 线性表

### 2.2 线性表的顺序表示(Page 19)

1. 从顺序表中删除具有最小值的元素(假设唯一)，并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。

   **思路**:步骤1.查找最小元素 步骤2.用最后一个元素填补删除的元素(除非删除的是最后一个元素)

   **代码**:

   ~~~ c++
   bool Del_Min(SqList &L, ElemType &value){
       if(L.length == 0)
           return false;
       int min_index = 0;
       value = L.data[0];
       for(int i = 1; i < L.length; i++){
   		if(L.data[i] < L.data[min_index]){
               min_index = i;
           	value = L.data[i];
           }
       }
       //这是一处我认为题目可能有bug的地方：当删除最后一个元素的时候，空出的位置不应该有元素填补
       if(min_index == L.length-1){
           L.data[min_index] = L.data[length];
       	return true;
       }
       L.data[min_index] = L.data[L.length-1];
       L.length--;
       return true;
   }
   ~~~

2. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。

   **思路**:通过一个辅助变量temp来交换首尾两个元素，然后交换第二个和倒二个元素，然后交换第三个倒三个元素……以此类推

   **代码**:

   ~~~c++
   void Reverse(SqList &L){
       ElemType temp;
       for(int i = 0; i < L.length/2; i++){
           temp = L.data[i];
           L.data[i] = L.data[L.length-1-i];
           L.data[L.length-1-i] = temp;
       }
   }
   ~~~

3. 对长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。

   **思路**:用k记录顺序表L中不等于x的元素个数(即需要保存的元素个数)，边扫描边统计k，并将不等于x的元素挪动到第k个位置，最后修改L的长度

   **代码**:

   ~~~c++
   void del_x_1(SqList &L, ElemType x){
       int k = 0;
       for(int i = 0; i < L.length; i++){
           if(L.data[i] != x){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
   }
   ~~~

4. 从有序顺序表中删除其值在给定s与t之间(要求s<t)的所有元素，如果s或t不合理或顺序表为空，则显示出错信息并退出运行。

   **思路**:首先判断s与t是否合理或顺序表是否为空。观察到顺序表是“有序”的，可以用二分搜索找到第一个大于等于s的值的位置pos1以及第一个大于t的值的位置pos2，将pos2之后的值挪动到pos1之后，更新L的长度

   **代码**:

   ~~~c++
   bool Del_s_t2(SqList &L, ElemType s, ElemType t){
       if(s >= t || L.length == 0){
           return false;
       }
       int pos1 = -1, pos2 = L.length;
       //为了省事就不用二分搜索确定pos1和pos2了，直接用遍历确定
       for(int i = 0; i< L.length; i++){
           if(L.data[i] < s){
               pos1 = i;
           }
           if(L.data[i] > t){
               pos2 = i;
               break;
           }
       }
       pos1 += 1;//第一个大等于s的位置
       //用pos2及之后的值覆盖pos1到pos2-1之间的的值
       while(pos2 < L.length){
           L.data[pos1] = L.data[pos2];
           pos1++;
           pos2++;
       }
       L.length = pos1;
       return true;
   }
   ~~~

5. 从顺序表中删除其值在给定值s与t之间(包含s和t，要求s<t)的所有元素，如果s或t不合理或顺序表为空，则显示出错信息并退出运行。

   **思路**:用k记录顺序表L中值不在s与t之间的元素个数(即需要保存的元素个数)，边扫描边统计k，令值不在s与t之间的元素挪动到第k个位置，最后修改L的长度

   **代码**:

   ~~~ c++
   bool Del_S_t(SqList &L, ElemType s, ElemType t){
       if(s >= t || L.length == 0){
           return false;
       }
       int k = 0;
       for(int i = 0; i < L.length; i++){
           if(L.data[i] < s || L.data[i] > t){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
       return true;
   }
   ~~~

6. 从有序顺序表中删除其值重复的元素，使表中所有的元素值均不同。

   **思路**:由于数组是有序的，则重复的数必定连续出现，用k记录有序表中值不重复的元素个数，之后边扫描边统计k，当遇到的元素重复时，则跳过，否则将位于k位置的元素更新为当前元素，并增加k的值

   **代码**:

   ~~~c++
   void Delete_Same(SqList &L){
       if(L.length == 1){
           return;
       }
       int k = 1;
       for(int i = 1; i < L.length; i++){
           if(L.data[i] != L.data[k-1]){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
   }
   ~~~

7. 将两个有序顺序表合成为一个新的有序顺序表，并由函数返回结果顺序表。

   **思路**:假定两个顺序表是顺序递增的，使用两个指针i和j分别指向两个表的第一个元素，每次比较中挑选较小的元素放入新表，相应指针向前移动，当其中一根指针到达表的末端时，将另一张表的剩余元素都放入新表中。

   **代码**:

   ~~~c++
   bool Merge(SqList &A, SqList &B, SqList &C){
       if(A.length + B.length > C.maxSize){
           return false;
       }
       int i = 0, j = 0, k = 0;
       while(i < A.length && j < B.length){
           if(A.data[i] < B.data[j]){
               C.data[k++] = A.data[i++];
           }
           else{
               C.data[k++] = B.data[j++];
           }
       }
       while(i < A.length){
           C.data[k++] = A.data[i++];
       }
       while(j < B.length){
           C.data[k++] = B.data[j++];
       }
       C.length = A.length + B.length;
       return true;
   }
   ~~~

8. 已知在一维数组A[m+n]中依次存放两个线性表(a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>m</sub>)和(b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,...,b<sub>n</sub>)，试编写一个函数，将数组中两个顺序表的位置互换，即(b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,...,b<sub>n</sub>)放在(a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>m</sub>)的前面。

   <font color=red>**思路**</font>:<font color = blue>先把A数组倒过来，即令A[m+n] = (a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>m</sub>,b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,...,b<sub>n</sub>)倒转为A[n+m] = (b<sub>n</sub>,b<sub>n-1</sub>,b<sub>n-2</sub>,...,b<sub>1</sub>,a<sub>m</sub>,a<sub>m-1</sub>,a<sub>m-2</sub>,...,a<sub>1</sub>)，然后再分别对n和m部分分别进行倒转，得到结果</font>

   **代码**:

   ~~~c++
   void Exchange(DataType &A[], int m, int n, int arraySize){
       Reverse(A, 0, m+n-1, arraySize);
       Reverse(A, 0, n-1, arraySize);
       Reverse(A, n, m+n-1, arraySize);
   }
   
   void Reverse(DataType &Arr[], int left, int right, int arraySize){
       if(left >= right || right >= arraySize){
           return;
       }
       DataType temp;
       for(int i = 0; i < (right-left+1)/2; i++){
           temp = Arr[left+i];
           Arr[left+i] = Arr[right-i];
       	Arr[right-i] = temp;
       }
   }
   ~~~

9. 线性表(a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>n</sub>)中的元素递增有序且按顺序存储于计算机内，要求设计一算法，完成用最少时间在表中查找数值为x的元素，若找到则将其与后继元素位置相交换，若找不到则将其插入表中，并使表中元素仍递增有序。

   **思路**:首先用二分查找找到x的位置(或第一个大于x的位置)，然后将x插入或交换

   **代码**:

   ~~~c++
   void SerarchExchangeInsert(SqList &A, ElemType x){
       int pos = BinarySearch(A, x, 0, A.length-1);
       //找到该元素，进行交换
       if(A.data[pos] == x){	
           ElemType temp = A.data[pos];
           A.data[pos] = A.data[pos+1];
           A.data[pos+1] = temp;
       }
       //未找到该元素，进行插入
       else{	
   		A.length++;
           for(int i = A.length; i > pos; i--){
               A.data[i] = A.data[i-1];
           }
           A.data[pos] = x;
       }
   }
   
   int BinarySearch(SqList A, ElemType x, int left, int right){
       int mid = (left+right)/2;
       while(left <= right){
           if(A.data[mid] == x){
               return mid;
           }
           else if(A.data[mid] > x){
               right = mid - 1;
           }
           else{
               left = mid + 1;
           }
       }
       return left;
   }
   ~~~

10. (2010统考真题)设将n(n>1)个整数存放到一维数组R中，设计一个在时间和空间两方面都尽可能高效的算法，将R中保存的序列循环左移p(0<p<n)个位置，即将R中的数据由(X<sub>0</sub>,X<sub>1</sub>,...,X<sub>n-1</sub>)变换为(X<sub>p</sub>,X<sub>p+1</sub>,...,X<sub>n-1</sub>,X<sub>0</sub>,X<sub>1</sub>,...,X<sub>p-1</sub>)。

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:题目要求将R中的数据由(X<sub>0</sub>,X<sub>1</sub>,...,X<sub>p-1</sub>,X<sub>p</sub>,X<sub>p+1</sub>,...X<sub>n-1</sub>)变换为(X<sub>p</sub>,X<sub>p+1</sub>,...,X<sub>n-1</sub>,X<sub>0</sub>,X<sub>1</sub>,...,X<sub>p-1</sub>)，令(X<sub>0</sub>,X<sub>1</sub>,...,X<sub>p-1</sub>)为a，(X<sub>p</sub>,X<sub>p+1</sub>,...X<sub>n-1</sub>)为b，则题目要求将数组R = {a,b}变为 {b,a}。首先将R逆转为R<sup>-1</sup>={b<sup>-1</sup>,a<sup>-1</sup>}，然后再对R<sup>-1</sup>中的b<sup>-1</sup>和a<sup>-1</sup>各自逆转，即可得到答案{b,a}。(思路同第8题)

    **代码**:

    ~~~c++
    void Exchange(DataType &A[], int m, int n, int arraySize){
        Reverse(A, 0, m+n-1, arraySize);
        Reverse(A, 0, n-1, arraySize);
        Reverse(A, n, m+n-1, arraySize);
    }
    
    void Reverse(DataType &Arr[], int left, int right, int arraySize){
        if(left >= right || right >= arraySize){
            return;
        }
        DataType temp;
        for(int i = 0; i < (right-left+1)/2; i++){
            temp = Arr[left+i];
            Arr[left+i] = Arr[right-i];
        	Arr[right-i] = temp;
        }
    }
    ~~~

    **复杂度分析**:时间复杂度O(n)，空间复杂度O(1)

11. (2011统考真题)一个长度为L(L>=1)的升序序列S，处在第L/2(向上取整)个位置的数称为S的中位数，例如，若序列S<sub>1</sub>=(11,13,15,17,19)，则15为S<sub>1</sub>的中位数，两个序列的中位数是含它们所有元素的升序序列的中位数，例如，若S<sub>2</sub>=(2,4,6,8,20)，则S<sub>1</sub>和S<sub>2</sub>的中位数是11，现在有两个等长升序序列A和B，试设计一个在时间和空间上都尽可能高效的算法，找出两个序列A和B的中位数。

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:分别求出A的中位数a和B的中位数b。当a=b时，则中位数就为a或b；当a<b，令A舍弃a之前的部分成为A'，令B舍弃b之后的部分成为B'，然后求A'和B'的中位数；当a>b，令A舍弃a之后的部分成为A'，令B舍弃b之前的部分成为B'，然后求A'和B'的中位数。重复上述过程，直到a=b，或者A'的元素或B'的元素只剩一个时，较小的那个数即为中位数

    <font color = red>**代码**</font>:

    <font color = red>思路易得，但代码很容易出bug!</font>

    ~~~c++
    int M_Search(int A[], int B[], int n){
        int a_left = 0, a_right = n-1, b_left = 0, b_right = n-1;
        int a_mid, b_mid;
        while(a_left < a_right && b_left < b_right){
            a_mid = (a_left+a_right)/2;
            b_mid = (b_lett+b_right)/2;
            if(A[a_mid] == B[b_mid]){
                return A[a_mid];
            }
            else if(A[a_mid] < B[b_mid]){
                //元素个数为偶数，舍弃A中点以前的数(包含中点)，B中点以后的数(不包含中点)
                if((a_right-a_left+1) % 2 == 0){
                    a_left = a_mid + 1;
                    b_right = b_mid;
                }
                //元素个数为奇数，舍弃A中点以前的数(不包含中点)，B中点以后的数(不包含中点)
                else{
                	a_left = a_mid;
                	b_right = b_mid;
            	}
            }
            else{
                //元素个数为偶数，舍弃A中点以后的数(不包含中点)，B中点以前的数(包含中点)
                if((a_right-a_left+1) % 2 == 0){
                    b_left = b_mid + 1;
                    a_right = a_mid;
                }
                //元素个数为奇数，舍弃A中点以后的数(不包含中点)，B中点以前的数(不包含中点)
                else{
                    b_left = b_mid;
                	a_right = a_mid;
                }
            }
        }
        return A[a_left] < B[b_left] ? A[a_left] : B[b_left];
    }
    ~~~

    **复杂度分析**:时间复杂度O(logN)，空间复杂度O(1)

12. (2013统考真题)已知一个整数序列A=(a<sub>0</sub>,a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n-1</sub>)，其中0<=a<sub>i</sub><n(0<=i<n)。若存在a<sub>p<sub>1</sub></sub>=a<sub>p<sub>2</sub></sub>=...=a<sub>p<sub>m</sub></sub>=x且m>n/2 (0<=p<sub>k</sub><n, 1<=k<=m)，则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5)，则5为主元素；又如A=(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的n个元素保存在一维数组中，请设计一个尽可能高效的算法，找出A的主元素，若存在主元素，则输出该元素；否则输出-1。

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    <font color = red>**思路**</font>:主元素的定义其实就是出现次数超过数组长度一半的元素，如果出现次数超过一半，那这个元素必定唯一，且至少在数组的某一处连续出现过两次，我们就从这个入手，标记出一个可能成为主元素的元素Num，然后重新计数，最终确定Num是否为主元素。

    算法分为以下两步：
    
    ①.选取侯选主元素，依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数重新加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述流程，直到扫描完全全部数组元素。
    
    ②.判断c中元素是否为真的主元素，再次扫描该数组，统计c中元素出现的次数，若大于n/2，则为主元素，否则序列中不存在主元素。
    
    <font color = red>最优思路难得，次优思路很容易想到</font>
    
    **代码**:
    
    ~~~c++
    int Majority(int A[], int n){
        if(n < 1){
            return -1;
        }
        if(n == 1){
            return A[0];
        }
        int result = A[0], count = 1;
        for(int i = 1; i < n; i++){
            if(A[i] == result){
                count++;
            }
            else{
                count--;
                if(count == 0){
                    result = A[i];
                    count = 1;
                }
            }
        }
        if(count > 1){
            count = 0;
        	for(int i = 0; i < n; i++){
                if(A[i] == result){
                    count++;
                }
            }
        }
        return count > n/2 ? result : -1;
    }
    ~~~
    
    **复杂度分析**:时间复杂度O(N)，空间复杂度O(1)
    
13. (2018统考真题)给定一个含n(n>=1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5,3,2,3}中未出现的最小正整数是1；数组{1,2,3}中未出现的最小正整数是4

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:由于本题只要求在时间上尽可能高效，因此采用空间换时间的思路。设计一个数组B，其长度为n，记录着1-n正整数出现的个数。遍历原数组A，对每个出现的正整数A\[i](应满足A[i]<=n，因为最小正整数必定介于[1,n+1])，令B[A[i]-1]++，最后遍历B，找到第一个B[j]=0的索引j，则未出现的最小正整数是j+1

    **代码**:

    ~~~c++
    int findMissMin(int A[], int n){
        int *B = new int[n];
        memset(B, 0, sizeof(int)*n);
        for(int i = 0; i < n; i++){
            if(A[i] > 0 && A[i] <= n){
                B[A[i]-1]++;
            }
        }
        for(int j = 0; j < n; j++){
            if(B[j] == 0) return j+1;
        }
        return n+1;
    }
    ~~~

    **复杂度分析**:时间复杂度O(N)，空间复杂度O(N)



### 2.3 线性表的链式表示(Page 40)

1. 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点。

   **思路**:用一个结点p表示待删除结点，当当前结点L的值为x时，p指向L，L移动到下一个结点，随后释放p。当前结点值不为x时，观察当前结点的下一个结点，当下一个结点不为空且值为x，则令p指向L->next，L指向L->next->next，随后释放p，并继续执行递归函数，直到移动到最后一个结点。

   **代码**:

   ~~~c++
   void Del_X_3(Linklist &L, ElemType x){
       if(L == NULL){
           return;
       }
       LNode * p;
       //当前结点的值就是x，删除该结点，移动到下一个结点
       if(L->data == x){
       	p = L;
           L = L->next;
           delete(p);
           Del_X_3(L, x);
       }
       else{
           //当前结点的下一个结点不为空，且值为x，删除当前结点的下一个结点
           if(L->next && L->next->data == x){
               p = L->next;
               L->next = L->next->next;
               delete(p);
           }
           Del_X_3(L->next, x);
       }
   }
   ~~~

   **注意**:我认为课本答案是错误的，因为其没有处理待删除结点的前后结点之间的关系

2. 在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法以实现上述操作。

   **思路**:遍历链表，由于是带头结点的元素，不用判断第一个结点就是x的情况，只需要判断：如果当前结点的下一个结点不为空且值为x时，用一个变量p指向当前结点的下一个结点，令当前结点指向下下个结点，并释放变量p。

   **代码**:

   ~~~c++
   void Del_X_1(Linklist &L, ElemType x){
       LNode *head = L;
       while(head){
           if(head->next && head->next->data == x){
               LNode *p = head->next;
               head->next = head->next->next;
               delete(p);
           }
           head = head->next;
       }
   }
   ~~~

3. 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个节点的值。

   **思路**:用头插法把每个结点重新插入到头结点后，就能完成链表的逆置，然后遍历输出链表的值即可。

   **代码**:

   ~~~c++
   void R_Print(Linklist L){
       LNode *p = L->next;
       L->next = NULL;
       while(p){
           LNode *q = p;
           p = p->next;
           q->next = L->next;
           L->next = q;
       }
       p = L->next;
       while(p){
           printf(p->data);
           p = p->next;
       }
   }
   ~~~

4. 试编写在带头结点的单链表L中删除一个最小值结点的高效算法(假设最小值的结点是唯一的)。

   **思路**:遍历链表找到最小值结点的前驱节点，随后删除最小值结点

   **代码**:

   ~~~c++
   Linklist Delete_Min(Linklist &L){
       if(L->next == NULL){
           return L;
       }
       ElemType minnum = L->next->data;
       LNode *pre = L;
       LNode *cur = L;
       //查找最小值结点的前驱结点
       while(cur->next){
           if(cur->next->data < minnum){
           	minnum = cur->next->data;
               pre = cur;
           }
           cur = cur->next;
       }
       //删除最小值结点
       LNode *p = pre->next;
       pre->next = pre->next->next;
       delete(p);
       return L;
   }
   ~~~

5. 试编写算法将带头结点的单链表就地逆置，所谓“就地“就是辅助空间复杂度为O(1)。

   **思路**:这道题和第3题的思路一致，即：用头插法把每个结点重新插入到头结点

   **代码**:

   ~~~c++
   Linklist Reverse_1(Linklist &L){
       LNode *p = L->next;
       LNode *q;
       L->next = NULL;
       while(p){
           q = p;
           p = p->next;
           q->next = L->next;
           L->next = q;
       }
       return L;
   }
   ~~~

6. 有一个带头结点的单链表L，设计一个算法使其所有元素递增有序。

   **思路**:可以把链表的值存入数组，然后用归并或快排，随后再重新组建一个链表，这里不采用这个方式，而采用链式的插入排序。

   **代码**:

   ~~~c++
   void Sort(Linklist &L){
       if(L->next == NULL){
           return;
       }
       LNode *p = L->next;
       LNode *q;
       LNode *r
       L->next = NULL;
       while(p){
           if(p->next){
           	q = p->next;
           	p->next = p->next->next;
               //把q插入到排好序的链表中
               r = L;
               while(r->next && r->next->data < q->data){
                   r = r->next;
               }
               q->next = r->next;
               r->next = q;
           }
           p = p->next;
       }
   }
   ~~~

7. 设在一个带表头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值(作为函数参数给出)之间的元素的元素(若存在)。

   **思路**:遍历链表，找到值介于给定两个值之间的元素的前驱，删除他们的后继元素即可

   **代码**:

   ~~~c++
   void RangeDelete(Linklist &L, int min, int max){
       LNode *pre = L;
       LNode *q;
       while(pre){
           if(pre->next && pre->next->data < max && pre->next->data > min){
               q = pre->next;
               pre->next = pre->next->next;
               delete(q);
           }
           pre = pre->next;
       }
   }
   ~~~

8. 给定两个单链表，编写算法找出两个链表的公共结点。

   <font color = red>**思路**</font>:公共结点的意思就是存在某个结点p，链表A和链表B都有p结点，且在p结点之后的结点均相同。解这道题可以用最简单的O(N<sup>2</sup>)的思路蛮算，但其实有更简单的方法。我们注意到：当两个链表拥有公共结点时，最后一个结点一定是一样的！但如果我们从各自的开头开始遍历，不一定能保证同时到达公共结点！因此想要同时到达公共起点，我们应该得到两个链表长度，并求出其差值diff，令较长的链表从diff开始，较短的链表从头结点开始遍历，这样能保证二者同时到达结尾，也就能保证同时遇到第一个公共结点啦。

   **代码**:

   ~~~c++
   Linklist Search_1st_Common(Linklist &L1, Linklist &L2){
       int length1 = 0, length2 = 0, diff;
       LNode *p1 = L1;
       LNode *p2 = L2;
       while(p1->next){
           length1++;
           p1 = p1->next;
       }
       while(p2->next){
           length2++;
           p2 = p2->next;
       }
       p1 = L1;
       p2 = L2;
    	if(length1 < length2){
           diff = length2 - length1;
           while(diff--){
               p2 = p2->next;
           }
       }   
       else{
           diff = length1 - length2;
           while(diff--){
   			p1 = p1->next;
           }
       }
       while(p1 && p2){
   		if(p1 == p2){
               return p1;
           }
           p1 = p1->next;
           p2 = p2->next;
       }
       return NULL;
   }
   ~~~

9. 给定一个带表头结点的单链表，设head为头指针，结点结构为(data,next)，data为整型元素，next为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间(要求：不允许使用数组作为辅助空间)

   **思路**:用链表的插入排序方式从小到大排序完后，再遍历链表输出元素并释放空间

   **代码**:

   ~~~c++
   void Min_Delete(Linklist &head){
       LNode *p = head;
       LNode *q;
       Lnode *r;
       while(p){
           if(p->next){
           	q = p->next;
           	p->next = p->next->next;
               r = head;
               while(r->next && r->next->data < q->data){
                   r = r->next;
               }
               q->next = r->next;
               r->next = q;
           }
           p = p->next;
       }
       p = head;
       while(p->next){
           print(p->next->data);
           q = p->next;
           p->next = p->next->next;
           delete(q);
       }
    	delete(head);   
   }
   ~~~

10. 将一个带头结点的单链表A分解为两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变。

    **思路**:设计一个计数器就可以了

    **代码**:

    ~~~c++
    Linklist DisCreat_1(Linklist &A){
        Linklist *B = new Linklist;
        B->next = NULL;
        int count = 1;
        LNode *p = A;
        LNode *b = B;
        LNode *q;
        while(p){
            if(p->next && count % 2 == 0){
                q = p->next;
                p->next = p->next->next;
                q->next = NULL;
                b->next = q;
                b = b->next;    
            }
            count++;
            p = p->next;
        }
        return B;
    }
    ~~~

11. 设C={a<sub>1</sub>,b<sub>1</sub>,a<sub>2</sub>,b<sub>2</sub>,...,a<sub>n</sub>,b<sub>n</sub>}为线性表，采用带头结点的hc单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A={a<sub>1</sub>,a<sub>2</sub>,...a<sub>n</sub>}，B={b<sub>n</sub>,b<sub>n-1</sub>,...,b<sub>1</sub>}。

    **思路**:这题和上面那题思路几乎一样，区别在于B表使用的是头插法

    **代码**:

    ~~~c++
    Linklist DisCreat_2(Linklist &A){
        Linklist *B = new Linklist;
        B->next = NULL;
        LNode *p = A;
        LNode *q;
        LNode *b = B;
        int count = 1;
        while(p){
            if(p->next && count % 2 == 0){
                q = p->next;
                p->next = p->next->next;
                q->next = b->next;
                b->next = q;
            }
            count++;
            p = p->next;
        }
        return B;
    }
    ~~~

12. 在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素，例如(7,10,10,21,30,42,42,42,51,70)将变成(7,10,21,30,42,51,70)。

    **思路**:由于线性表递增有序，因此每遇到一个新数字时，判断与先前数字是否相同，如果数值相同则去掉该元素

    **代码**:

    ~~~c++
    void Del_Same(Linklist &L){
        if(L->next == NULL){
            return;
        }
        ElemType pre = L->next->data;
        LNode *p = L->next;
        LNode *q;
        while(p){
            if(p->next){
                q = p->next;
            	if(q->data == pre){
                    p->next = p->next->next;
                    delete(q);
                }
                else{
                    pre = q->data;
                }
            }
            p = p->next;
        }
    }
    ~~~

13. 假设有两个按元素值递增次序排列的线性表，均以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值次序递减的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。

    **思路**:用其中一个链表存放归并的结果即可，参考答案似乎没有体现移动某结点时，其“前驱”的“后继”关系的改变。即结点A->B->C->D，用头插法将B插入到表头时，没有令A->next=A->next->next，这是一个严重的错误！

    **代码**:

    ~~~c++
    void MergeList(Linklist &A, Linklist &B){
        LNode *p = A;
        LNode *q = B;
        LNode *l = A;
        l->next = NULL;
        LNode *a;
        LNode *b;
        while(p && q){
            if(p->next && q->next){
     			a = p->next;
                b = q->next;
                if(a->data < b->data){
                    p->next = p->next->next;
                	a->next = l->next;
                	l->next = a;
                    p = p->next;
                }
                else{
                    q->next = q->next->next;
                    b->next = l->next;
                    l->next = b;
                    q = q->next;
                }
            }
            else{
            	break;
            }
        }
        while(p){
            if(p->next){
                a = p->next;
                p->next = p->next->next;
                a->next = l->next;
                l->next = a;
            }
            p = p->next;
        }
        while(q){
            if(q->next){
                b = q->next;
                q->next = q->next->next;
                b->next = l->next;
                l->next = b;
            }
            q = q->next;
        }
       	return l;
    }
    ~~~

14. 设A和B是两个单链表(带头结点)，其中元素递增有序。设计一个算法从A和B中的公共元素产生单链表C，要求不破坏A、B的结点。

    **思路**:设计两个指针分别指向A和B，比较其指向的值，如果相等，生成一个结点并插入到链表C中，同时两个指针向后移，如果不等，较小的指针向后移动。

    **代码**:

    ~~~c++
    void Get_Common(Linklist A, Linklist B){
        Linklist *C = new Linklist;
        C->next = NULL;
        LNode *p = A->next;
        LNode *q = B->next;
        LNode *r = C;
        while(p && q){
            if(p->data == q->data){
                LNode *t = new LNode;
                t->data = p->data;
                t->next = NULL;
                r->next = t;
                r = r->next;
                p = p->next;
                q = q->next;
            }
            else if(p->data < q->data){
                p = p->next;
            }
            else{
                q = q->next;
            }
        }
    }
    ~~~

15. 已知两个链表A和B分别表示两个集合，其元素递增排列。编制函数，求A与B的交集，并存放于A链表中。

    **思路**:交集也就是A和B两个链表的公共元素，首先要求把公共元素提出来插入到A的队首，最后遍历A，由于头插法，公共元素会递减，当下一个结点的值大于该结点时，令该结点的下一个结点为NULL，并释放之后的结点即可。

    **代码**:

    ~~~c++
    Linklist Union(Linklist &A, Linklist &B){
        LNode *p = A;
        LNode *q = B;
        LNode *a, *b;
        LNode *l = A;
        l->next = NULL;
        //合并
        while(p && q){
        	if(p->next && q->next){
                a = p->next;
                b = q->next;
                if(a->data < b->data){
                    p = p->next;
                }
                else if(a->data > b->data){
                    q = q->next;
                }
                else{
                    p->next = p->next->next;
                    a->next = l->next;
                    l->next = a;
                    p = p->next;
                    q = q->next;
                }
            }   
            else{
                break;
            }
        }
    	//释放A
        p = A->next;
        while(p){
        	if(p->next && p->next->data > p->data){
                q = p->next;
                p->next = NULL;
                break;    
            }
            p = p->next;
        }
        while(q){
            a = q;
            q = q->next;
            delete(a);
        }
        return A;
    }
    ~~~

16. 两个整数序列A=a<sub>1</sub>,a<sub>2</sub>,...,a<sub>m</sub>和B=b<sub>1</sub>,b<sub>2</sub>,...,b<sub>n</sub>已经存入两个单链表中，设计一个算法，判断序列B是否是序列A的连续子序列。

    **思路**:有点像两个字符串的匹配算法，可以用kmp算法来优化，姑且使用暴力算法，时间复杂度为O(N^2)

    **代码**:

    ~~~c++
    int Pattern(Linklist A, Linklist B){
     	LNode *p = A->next;
        LNode *q = B->next;
        LNode *t;
        int result = -1;
        int count = 1;
        while(p && result == -1){
            if(p->data == q->data){
            	t = p->next;
                q = q->next;
                while(p && q){
                    if(p->data == q->data){
                		p = p->next;
                        q = q->next;
                    }
                    else{
                        break;
                    }
                }
            	if(q == NULL){
                    result = count;
                }
                else{
                    q = B->next;
                }
            }
            count++;
            p = p->next;
        }
     	return result;
     }
    ~~~

17. 设计一个算法，用于判断带头结点的循环双链表是否对称。

    **思路**:自头结点向后与头结点向前遍历，直到两个结点相遇(或相邻)，如果每次元素相等则对称，否则不对称

    **代码**:

    ~~~c++
    bool Symmetry(DLinklist L){
        DNode *p = L->next;
        DNode *q = L->prior;
        //答案的方法是q->next != p 显然比我的代码更好
        while(p != q && p->next != q){
            if(p->data == q->data){
                p = p->next;
                q = q->prior;
            }
            else{
                return false;
            }
        }
        if(q->data != q->data){
            return false;
        }
        return true;
    }
    ~~~

18. 有两个循环单链表，链表头指针分别为h1和h2，编写一个函数将链表h2链接到链表h1之后，要求链接后的链表仍保持循环链表形式。

    **思路**:找到第一个链表的链尾，将指针指向第二个链表的头结点，再将第二个链表的尾巴指向第一个链表的头结点

    **代码**:

    ~~~c++
    LinkList Link(Linklist &h1, Linklist &h2){
        LNode *p = h1;
        LNode *q = h2;
        while(p->next != h1){
            p = p->next;
        }
        while(q->next != h2){
            q = q->next;
        }
        p->next = h2;
        q->next = h1;
        return h1;
    }
    ~~~

19. 设有一个带头结点的循环单链表，其结点值均为正整数。设计一个算法，反复找出单链表中结点值最小的结点并输出，然后将该结点从中删除，直到单链表空为止，再删除头结点。

    **思路**:反复遍历链表，找出值最小的结点的前驱，删除其后继，直到链表为空。

    **代码**:

    ~~~c++
    void Del_All(Linklist &L){
        LNode *p = L->next;
        LNode *min = L->next;
        LNode *pre = L;
        LNode *r;
        while(L->next != L){
            //找到最小结点的前驱结点
            if(p->data <= min->data){
                min = pre;
            }
            p = p->next;
            pre = pre->next;
        	//每次p到达L时，就输出一次最小结点并删除
            if(p == L){
                cout<<min->data<<endl;
                r = min->next;
                min->next = min->next->next;
                r->next = NULL;
                delete(r);
                p = p->next;
                pre = pre->next;
            }
        }
        delete(L);
    }
    ~~~

20. 设头指针为L的带有表头结点的非循环双向链表，其每个结点中除有pred(前驱指针)、data(数据)和next(后继指针)域外，还有一个访问频度域freq。再链表被启用前，其值初始化为0。每当在链表中进行一次Locate(L,x)运算时，令元素值为x的结点中freq域的值+1，并使链表中结点保持按访问频度非增(递减)的顺序排列，同时最近访问的结点排在频度相同的结点前面，以便使频繁访问的结点总是靠近表头。试编写符合上述要求的Locate(L,x)运算的算法，该运算为函数过程，返回找到结点的地址，类型为指针型。

    **思路**:首先找到data为x的结点，为其增加freq，增加完后令其与左侧结点循环比较，如果该结点的freq大等于其左侧结点，继续左移，直到找到插入点。

    **代码**:

    ~~~c++
    DLinklist Locate(DLinklist &L, ElemType x){
        DNode *p = L->next;
        while(p && p->data != x){
            p = p->next;
        }
        if(p == NULL){
            cout<<"不存在值为"<<x<<"的结点\n";
            return;
        }
        p->freq += 1;
        DNode *q = p->pred;
        q->next = p->next;
        p->next->pred = q;
        while(q != L && q->freq <= p){
            q = q->pred;
        }
        p->pred = q;
        p->next = q->next;
        q->next->pred = p;
        q->next = p;   
    }
    ~~~

21. (2009统考真题)已知一个带有表头结点的单链表，结点结构为(data,link)，假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出点的data域的值，并返回1，否则只返回0。

    要求：

    <1>.给出算法的基本设计思想

    <2>.描述算法的详细实现步骤

    <3>.根据设计思想和实现步骤，采用程序设计语言描述算法(使用C、C++或Java语言实现)，关键之处请给出简要注释

    **思路**:设两个指针，一个指向头结点，一个指向头结点往后的第k-1个结点，两个指针同时向后移动，当后面的指针到达链尾时，前面的指针即指向倒数第k个结点

    **代码**:

    ~~~c++
    int Search_k(Linklist list, int k){
        LNode *p = list;
        LNode *q = list;
        for(int i = 0; i < k-1; i++){
            if(q == NULL){
                return 0;
            }
            q = q->link;
        }
        while(q != NULL){
            p = p->link;
            q = q->link;
        }
        return p->data;
    }
    ~~~

22. (2012统考真题)假定采用带头结点的单链表保存单词，当两个单词具有相同后缀时，可共享相同的后缀存储空间，例如"loading"和"being"的存储映像如图所示。设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为(data,next)，请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:若两个单词具有相同的后缀，那么后缀之后的所有字母一定相同。如果两个单词一长一短，则长的单词应该与短的单词从最后一个字母开始向前对齐(尾对齐)，然后同时开始向后遍历，直到找到公共后缀为止。

    **代码**:

    ~~~c++
    LNode* find_addr(LNode *str1, LNode*str2){
        LNode *p = str1;
        LNode *q = str2;
        int len1 = 0, len2 = 0;
        //计算两个单词的长度
        while(p != NULL){
            len1++;
            p = p->next;
        }
        while(q != NULL){
            len2++;
            q = q->next;
        }
        p = str1; q = str2;
        //指针前移直至对齐
        if(len2 > len1){
            for(int i = 0; i < len2-len1; i++){ p = p->next; }
        }
        else{
            for(int i = 0; i < len1-len2; i++){ q = q->next; }
        }
        //找到公共后缀
        while(p != NULL){
            if(p == q){
                break;
            }
            p = p->next;
            q = q->next;
        }
        return p;
    }
    ~~~

    **复杂度分析**:时间复杂度O(max(len(str1),len(str2)))，空间复杂度O(1)

23. (2015统考真题)用单链表保存m个整数，结点的结构为(data,link)，且|data|<=n(n为正整数)，现要求设计一个时间复杂度尽可能高效的算法，对于链表中data的绝对值相等的结点，仅保留第一次出现的结点而删除其余绝对值相等的结点。例如，若给定的单链表head为：head->21->-15->-15->-7->15->^，则删除结点后的head为：head->21->-15->-7->^

    要求：

    <1>.给出算法的基本设计思想

    <2>.使用C或C++语言，给出单链表结点的数据类型定义

    <3>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <4>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:由于要求时间复杂度尽可能高，因此，使用一个大小为n+1的整型数组A[]来存储0-n的数字是否出现。A[i]为1表示数字i出现过，A[i]为0表示数字i还未出现过。遍历链表，其中的每个结点都判断结点的绝对值是否在数组中，如果是，则跳过该节点并释放该节点，如果不是，则在数组中添加该结点的绝对值。(空间换时间)

    **代码**:

    ~~~c++
    struct LNode{
        int data;
        struct LNode* next;
    }
    
    void func(LNode *l, int n){
        int *A = new int[n+1];
        LNode *p = l;
        LNode *q = p->next;
        LNode *r;
        while(q){
            int i = q->data < 0 ? (-1)*q->data : q->data;
            if(A[i] == 0){
                A[i] = 1;
                p = p->next;
                q = q->next;
            }
            else{
                r = q;
                q = q->next;
            	p->next = q;
                delete(r);
            }
        }
    }
    
    ~~~

    **复杂度分析**:时间复杂度O(len(l))，空间复杂度O(n)

24. 设计一个算法完成以下功能：判断一个链表是否有环，如果有，找出环的入口点并返回，否则返回NULL。

    **思路**:

    设置两个快慢指针，初始两个指针都指向头结点，快指针一次移动2格，慢指针一次移动1格。如果存在环，由于快指针比慢指针移动得快，二者一定会相遇；如果快指针遇到null时，说明不存在环。

    当快慢指针相遇时，设头结点到入口的距离为a，相遇点与入口的距离为b，环长为c。因此，(a+b)为慢指针移动的长度，2(a+b)为快指针移动的长度，又因为快指针移动了a+b+若干个环长，即a+b+n\*c的长度，所以2(a+b)=a+b+n*c，推出a+b=n\*c。即，重新设两个指针，一个指针指向头结点，另一个指针指向相遇结点，二者每次向后移动1格，当二者相遇即指向的是环入口。

    **代码**:

    ~~~c++
    LNode* FindLoopStart(LNode *head){
        LNode *p = head;
        LNode *q = head;
        bool isRing = false;
        while(p != NULL && q != NULL){
            p = p->next;
            q = q->next;
            if(q != NULL){
                q = q->next;
            } else {
                break;
            }
    		if(q == p){
                isRing = true;
                break;
            }
        }
        if(!isRing){
            return NULL;
        }
        LNode *p = head;
        while(p != q){
            p = p->next;
            q = q->next;
        }
        return p;
    }
    ~~~

25. 设线性表L=(a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>)采用带头结点的单链表保存，链表中的结点定义如下：

    ~~~c
    typedef struct node{
        int data,
        struct node *next;
    }NODE;
    ~~~

    请设计一个空间复杂度为O(1)且时间上尽可能高效的算法，重新排列L中的各结点，得到线性表L'=(A=a<sub>1</sub>,a<sub>n</sub>,a<sub>2</sub>,a<sub>n-1</sub>,a<sub>3</sub>,a<sub>n-2</sub>...)。

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:先将L中的后一半结点逆转，用两个指针，一个指向头结点，一个指针指向中间结点，二者同时向后移动，将第二个指针遇到的元素插入到第一个指针后。

    **代码**:
    
    ~~~c++
    void change_list(NODE *h){
        if(h->next == NULL)
            return;
    	NODE *p = h;
        NODE *q = h;
        //先找到中间结点
        while(q != NULL){
            p = p->next;
            q = q->next;
            if(q == NULL){
                break;
            }
            q = q->next;
        }
        //p指向头结点，q指向中间结点
        q = p;
        p = h;
        //将q之后的结点顺序逆转
        Reverse(q);
        //移动插入链表元素
        NODE *r = q;
        q = q->next;
        p = p->next;
        r->next = NULL;
        while(q){
            r = q;
            q = q->next;
        	r->next = p->next;
            p->next = r;
            p = r->next;
        }
    }
    
    //采用头插法，逆转链表
    void Reverse(NODE *l){
    	NODE *p = l->next;
        NODE *q;
        l->next = NULL;
        while(p){
    		q = p;
            p = p->next;
            q->next = l->next;
            l->next = q;
        }
    }
    ~~~
    
    **复杂度分析**:时间复杂度O(n)，空间复杂度O(1)
    
    

## 第3章 栈和队列

### 3.1 栈(page 64)

1. 假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可以表示为仅由I和O组成的序列，可以操作的序列称为合法序列，否则称为非法序列。设计一个算法，判定所给定的操作序列是否合法，如果合法，返回true，否则返回false(假定被判定的操作序列已存入一维数组中)。

   **思路**:用一个变量来统计'I'出现的次数，每当'I'出现时，计数器自增，当遇到'O'时，计数器自减。由于任何时刻，I的次数必须大等于O的次数，即计数器的值必须>=0，因此在遍历数组的时候只要计数器小于0，即返回false。由于栈的终态必须为空，因此最后返回时需判断是否计数器为0。

   **代码**:

   ~~~c++
   bool Judge(char A[]){
       int i = 0;
       int count_i = 0;
       while(A[i] != '\0'){
           if(A[i] == 'I'){
               count_i++;
           }
           else{
               count_i--;
               if(count_i == -1){
                   return false;
               }
           }
           i++;
       }
       return count_i == 0;
   }
   ~~~

2. 设单链表的表头指针为L，结点结构由data和next两个域组成，其中data域为字符型，试设计算法判断该链表的全部n个字符是否中心对称。例如xyx、xyyx都是中心对称。

   **思路**:可以用一个栈存储链表的前一半元素，当链表到后半段时，用弹栈的方式把存储的内容弹出，如果最终栈为空，则为中心对称，如果中间弹出失败，则不为中心对称。

   **代码**:

   ~~~c++
   bool dc(Linklist L, int n){
       stack<char> st;
       LNode p = L;
       for(int i = 0; i < n/2; i++){
           st.push(p->data);
           p = p->next;
       }
       if(n % 2 == 1){
           p = p->next;
       }
       while(p){
           if(st.top() != p->data){
               return false;
           }
           st.pop();
           p = p->next;
       }
       return st.empty();
   }
   ~~~

3. 设有两个栈s1、s2都采用顺序栈方式，并共享一个存储区[0,...,maxsize-1]，为了尽量利用空间，减少溢出的可能，可采用栈顶相向、迎面增长的存储方式，试着设计s1和s2有关入栈和出栈的操作算法。

   **思路**:这道题即为双向栈的设计，重点在于入栈和出栈时的判错和判满这类问题的考虑。

   **代码**:

   ~~~c++
   struct DbStack{
       ElemType *stackSpace;
       int top[2];
       int maxSize;
   }
   
   void InitStack(DbStack &s, int maxsize){
       s.maxSize = maxsize;
       s.top[0] = -1;
       s.top[1] = maxsize;
       s.stackSpace = new ElemType[maxsize];
   }
   
   //stack_num取值为0或1，表示选择的栈
   int push(DbStack &s, int stack_num, ElemType x){
       if(stack_num != 0 && stack_num != 1){
           cout<<"指定的栈错误！"<<endl;
           return -1;
       }
       if(s.top[1] - s.top[0] == 1){
           cout<<"栈空间已满！"<<endl;
           return -2;
       }
       if(stack_num == 0){
           s.stackSpace[++s.top[0]] = x;
           cout<<"操作成功!"<<endl;
           return 0;
       }
       else{
           s.stackSpace[--s.top[1]] = x;
           cout<<"操作成功!"<<endl;
           return 1;
       }
   }
   
   //x为pop操作所返回的值
   int pop(DbStack &s, int stack_num, ElemType &x){
       if(stack_num != 0 && stack_num != 1){
           cout<<"指定的栈错误！"<<endl;
           return -1;
       }
       if(stack_num == 0){
           if(top[0] == -1){
               cout<<"栈1内容为空"<<endl;
               return -2;
           }
           x = s.stackSpace[s.top[0]--];
           cout<<"操作成功!"<<endl;
           return 0;
       }
       else{
           if(top[1] == s.maxSize){
               cout<<"栈2内容为空"<<endl;
               return -3;
           }
           x = s.stackSpace[s.top[1]++];
           cout<<"操作成功!"<<endl;
           return 0;
       }
   }
   ~~~

   ### 3.2 队列(page 77)

   1. 若希望循环队列中的元素都能得到利用，则需设计一个标志域tag，并以tag的值为0或1来区分队头指针front和队尾指针rear相同时的队列状态是“空”还是“满”。试编写与此结构相应的入队和出队算法。

      **代码**:

      ~~~c++
      struct Queue{
          int front;
          int rear;
          //tag为0表示front与rear相同时队列为空，tag为1表示front与rear相同时队列为满
          int tag;
          int maxsize;
          ElemType *queueSpace;
      }
      
      void InitQueue(Queue &q, int maxSize){
          if(maxSize <= 0){
      		cout<<"queue's maxsize shouldn't <= 0\n";
              return;
          }
          q.maxsize = maxSize;
          q.queueSpace = new ElemType[maxSize];
          q.front = 0;
          q.rear = 0;
          q.tag = 0;
      }
      
      bool EnQueue(Queue &q, ElemType X){
          if(q.tag == 1 && q.front == q.rear){
              return false;
          }
          q.queueSpace[q.rear] = X;
          q.rear = (q.rear + 1) % q.maxsize;
          if(q.rear == q.front){
              q.tag = 1;
          }
          return true;
      }
      
      bool DeQueue(Queue &q, ElemType &X){
          if(q.tag == 0 && q.front == q.rear){
              return false;
          }
          X = q.queueSpace[q.front];
          q.front = (q.front + 1) % q.maxsize;
          if(q.front == q.rear){
              q.tag = 0;
          }
          return true;
      }
      ~~~

   2. Q是一个队列，S是一个空栈，实现将队列中的元素逆置的算法。

      **思路**:显然把队列中的元素全部出队列入栈，再把栈内的元素全部出栈入队列就可以了

      **代码**:

      ~~~c++
      void Inverse(Stack S, Queue &Q){
          ElemType x;
          while(!QueueEmpty(Q)){
      	    DeQueue(Q, x);
              Push(S, x);
          }    
          while(!StackEmpty(S)){
              Pop(S, x);
              EnQueue(Q, x);
          }
      }
      ~~~

   3. 利用两个栈S1、S2来模拟一个队列，已知栈的四个运算定义如下：

      ~~~c++
      Push(S, x);			//元素X入栈S
      Pop(S, X);			//S出栈并将出栈值赋给X
      StackEmpty(S);		//判断栈是否为空
      StackOverflow(S);	//判断栈是否满
      ~~~

      如何利用栈的运算来实现该队列的3个运算(形参由读者自己设计)

      ~~~c++
      EnQueue;			//将元素x入队
      DeQueue;			//出队，将出队元素存储在x中
      QueueEmpty;			//判断队列是否为空
      ~~~

      **思路:**

      入队：将元素都压入其中一个栈(不妨使用S1)，即完成入队。

      出队：将所有元素从S1弹出并压入S2，同时弹出S2的第一个元素，即为出队，弹出后，将所有元素重新从S2压入S1(重新入队)。

      判空：判断S1是否为空。

      **代码:**

      ~~~c++
      bool EnQueue(Stack &S1, ElemType X){
          if(StackOverflow(S1)){
              return false;
          }
          Push(S, X);
          return true;
      }
      
      bool DeQueue(Stack &S1, Stack &S2, ElemType &X){
          if(StackEmpty(S1)){
              return false;
          }
          ElemType Y;
          while(!StackEmpty(S1)){
              Pop(S1, Y);
              Push(S2, Y);
          }
          Pop(S2, X);
          while(!StackEmpty(S2)){
              Pop(S2, Y);
              Push(S1, Y);
          }
          return true;
      }
      
      bool QueueEmpty(Stack S1){
          return StackEmpty(S1);
      }
      ~~~

   4. (2019统考真题)请设计一个队列，要求满足：①初始时队列为空；②入队时，允许增加队列占用空间；③出队后，出队元素所占用的空间可以重复使用，即整个队列所占用的空间只增不减；④入队操作和出队操作的时间复杂度始终为O(1)。请回答下列问题：

      <1>.该队列是应选择链式存储结构，还是顺序存储结构？

      **解答:**

      分析4个条件。

      ①.顺序和链式都能实现。

      ②.顺序不容易实现，链式容易实现。

      ③.顺序不容易实现，链式容易实现。

      ④.顺序和链式都容易实现。

      综上所述，应该选择链式存储结构。

      <2>.画出队列的初始状态，并给出判断队空和队满的条件。

      **解答:**

      初始时front = rear，且rear->next=front，

      队空：front = rear，

      队满：链队没有队满这一说。

      <3>.画出第一个元素入队后的队列状态。

      **解答:**

      front->x->front;

      <4>.给出入队操作和出队操作的基本过程。

      **代码:**

      ~~~c++
      struct LinkNode{
          ElemType data;
          LinkNode *next;
      }
      
      struct LinkQueue{
          LinkNode *front;
          LinkNode *rear;
      }
      
      void InitQueue(LinkQueue &q){
          q->front = new LinkNode;
          q->rear = q.front;
          q->rear->next = q.front;
      }
      
      bool EnQueue(LinkQueue &q, ElemType x){
      	//队尾没有空闲元素
          if(q->rear->next == q->front){
              LinkNode *p = new LinkNode;
              p->data = x;
              p->next = front;
              q->rear->next = p;
              q->rear = p;
          }
          //队尾有空闲元素
          else{
              q->rear->next->data = x;
              q->rear = q->rear->next;
          }
          return true;
      }
      
      bool DeQueue(LinkQueue &q, ElemType &x){
          //队列为空
          if(q->rear == q->front){
              return false;
          }
          //队列不空
          x = q->front->data;
          q->front = q->front->next;
          return true;
      }
      
      bool QueueEmpty(LinkQueue q){
          return q->front == q->rear;
      }
      ~~~

   ### 3.3 栈和队列的应用(page 91)

   1. 假设一个算术表达式中包含圆括号、方括号和花括号三种类型的括号，编写一个算法判别表达式中的括号是否配对，以字符'\0'作为算术表达式的结束符。

      **思路:**

      使用一个栈存储括号的左侧部分，然后进行括号匹配。遇到左括号时入栈，遇到右括号时检查栈顶元素是不是其对应的左括号，如果是则出栈，如果不是则括号不匹配。最终判断栈是否为空，如果为空则括号匹配，否则则不匹配。

      **代码:**

      ~~~c++
      //exp指的是表达式(expression)
      bool BracketMatch(char* exp){
          stack<char> st;
          int i = 0;
          while(exp[i] != '\0'){
              if(exp[i] == '(' || exp[i] == '[' || exp[i] == '{'){
                  st.push(exp[i]);
              }
              else if(exp[i] == ')'){
                  if(st.size() > 0 && st.top() == '('){
                      st.pop();
                  }
                  else{
                      return false;
                  }
              }
              else if(exp[i] == ']'){
                  if(st.size() > 0 && st.top() == '['){
                      st.pop();
                  }
                  else{
                      return false;
                  }
              }
              else if(exp[i] == '}'){
                  if(st.size() > 0 && st.top() == '{'){
                      st.pop();
                  }
                  else{
                      return false;
                  }
              }
              i++;
          }
          return st.size() == 0;
      }
      ~~~

   2. 按下图所示铁道进行车厢调度(注意，两侧铁道均为单向行驶道，火车调度站有一个用于调度的“栈道”)，火车调度站的入口处有n节硬座和软座车厢(分别用H和S表示)等待调度，试编写算法，输出对这n节车厢进行调度的操作(即入栈和出栈操作)序列，以使所有的软座车厢都被调整到硬座车厢之前。

      **思路:**

      用一个栈(栈道)存储硬座车厢，当遇到硬座时则入栈，遇到软座时直接放行。

      **代码:**

      ~~~c++
      void Train_Arrange(char *train){
          char *p = train, *q = train;
          stack<char> s;
          while(*p != '\0'){
              if(*p == 'H'){
                  s.push(*p);
              }
              else if(*p == 'S'){
                  *q = *p;
                  q++;
              }
              p++;
          }
          while(!s.empty()){
              char c = s.pop();
              *q = c;
              q++;
          }
      }
      ~~~

   3. <font color = red>利用一个栈实现以下递归函数的非递归计算。</font>

      P<sub>n</sub>(x) = 

      * 1        		                         (n = 0)
      * 2x                                       (n = 1)
      * 2xP<sub>n-1</sub>(x) - 2(n-1)P<sub>n-2</sub>(x)	(n > 1)

      <font color = red>**思路:**</font>

      设置一个栈保存n和对应的P<sub>n</sub>(x)的值val，栈中相邻元素的P<sub>n</sub>(x)有题目中关系，然后边出栈边计算P<sub>n</sub>(x)，栈空时，对应的值就计算出来了。

      **代码:**

      ~~~c++
      double P(int n, double x){
          struct stack{
              int n;
              double val;
          }
          stack st = new stack[n];
          int top = -1;
          //令fir(st)_val表示P<n-1>(x)的值，sec(ond)_val表示P<n-2>(x)的值，初始时，假定n>1
          double fir_val = 2*x;		//当n为2时，值为P<1>(x)=2*x
          double sec_val = 1;			//当n为2时，值为P<0>(x)=1
          for(int i = n; i >= 2; i--){
              st[++top] = i;
          }
          while(top >= 0){
              st[top].val = 2*x*fir_val - 2*(n-1)*sec_val;
              //让fir_val和sec_val始终分别表示P<n-1>(x)和P<n-2>(x)的值
              sec_val = fir_val;
              fir_val = st[top].val;
              top--;
          }
          if(n == 1){
              return sec_val;
          }
          return fir_val;
      }
      ~~~

   4. 某汽车轮渡口，过江渡船每次能载10辆车过江，过江车辆分为客车类和货车类，上渡船有如下规定：同类车先到先上船，客车先于货车上船，且每上4辆客车，才允许放上一辆货车，若等待客车不超过4辆，则以货车代替；若无货车等待，允许客车都上船。试设计一个算法模拟渡口管理。

      **思路:**

      1. 如果没有货车等待，就让所有客车上船
      2. 如果有货车等待，先看客车队列
         1. 客车队列不空，取客车上船，逢4辆客车取一辆货车上船
         2. 客车队列为空，把所有货车装船
      3. 客车货车队列均空，或是渡船容量达到10辆时结束

      **代码:**

      ~~~c++
      void manager(Queue &ferry, Queue &bus, Queue &truck){
          int ferry_weight = 0;//渡船上的车辆总数
          int bus_count = 0;//客车计数，逢4清零
          while(ferry_weight < 10){
              //没有货车等待，所有客车都上船
              while(ferry_weight < 10 && isEmpty(truck) && !isEmpty(bus)){
                  ElemType b = DeQueue(bus);
                  EnQueue(ferry,b);
                  ferry_weight++;
              }
              //有货车等待，先看客车队列
              while(ferry_weight < 10 && !isEmpty(bus) && bus_count < 4){
                  ElemType b = DeQueue(bus);
                  EnQueue(ferry,b);
                  ferry_weight++;
                  bus_count++;
                  //逢4，取货车队列中的一辆货车上船
                  if(ferry_weight < 10 && bus_count == 4 && !isEmpty(truck)){
                      ElemType t = DeQueue(truck);
                      EnQueue(ferry, t);
                      ferry_weight++;
                  }
              }
              //客车队列空空，货车队列不为空
              while(ferry_weight < 10 && isEmpty(bus) && !isEmpty(truck)){
              	ElemType t = DeQueue(truck);
                  EnQueue(ferry, t);
                  ferry_weight++;   
              }
              //客车和货车的队列都为空
              if(isEmpty(bus) && isEmpty(truck)){
                  return;
              }
          }
      }
      ~~~

   ### 3.4 特殊矩阵的压缩存储(page 102)
   
   

## 第4章 串

### 4.1 串的定义和实现(page 109)

### 4.2 串的模式匹配(page 111)



## 第5章 树与二叉树

### 5.1 树的基本概念(page 124)

### 5.2 二叉树的概念(page 128)

1. 已知一棵二叉树按顺序存储结构进行存储，设计一个算法，求编号分别为i和j的两个点的最近的公共祖先结点的值。

   **思路:**

   要解这道题，比较直观的想法就是求从根结点分别到i和j两个点的路径，找到这两条路径中最贴近于i和j的交点。

   由于二叉树采用顺序结构存储，编号为i的结点其父节点为int(i/2)，于是我们不断地寻找i和j中较大的那个结点的父节点，同时折半这个结点的值，直到找出交点。

   **代码:**

   ~~~c++
   ElemType Common_Ancestor(SqTree T[n+1], int i, int j){
       while(i != 1 && j != 1){
           if(i > j){
               i = i/2;
           }
           else if(i < j){
               j = j/2;
           }
           else{
               return T[i];
           }
       }
       return T[1];
   }
   ~~~

### 5.3 二叉树的遍历和线索二叉树(page 138)

1. -

2. -

3. 编写后续遍历二叉树的非递归算法。

   **思路:**

   要得到后序遍历的非递归算法，由于后续遍历是递归执行：遍历左子树->遍历右子树->遍历根的过程。

   因此，从根结点开始，每遍历到一个非空结点，将其入栈并优先遍历其左子树，当无左子树时，遍历结点的右子树，重复这一行为。

   在这个过程中，每当遍历到空指针，就从栈顶弹出最近的一个结点并访问(记录)，然后观察其父亲结点（位于当前栈的栈顶)，如果当前结点是其父亲结点的左结点，则需要遍历其父亲结点的右子树，如果该结点是其父亲结点的右结点，**说明其右子树已经遍历完毕**，下一步要弹出其父亲结点了，此时将指向该结点的指针设为空即可。

   **代码:**

   ~~~c++
   void PostOrder(BiTree T){
       stack<BiTree> st;
       BiTree p = T;
       while(p || !st.empty()){
       	if(p){
               st.push(p);
               //优先遍历左子
               if(p->left){
               	p = p->left;
               }
               //没有左子树了，遍历右子
               else{
                   p = p->right;
               }
           }
           //p为空指针
           else{
               //访问最近一个结点
               p = st.top();
               st.pop();
               visit(p->val);
               //观察最近一个结点与其父亲结点的关系
               //是父亲的左子，还要试着访问父亲的右子
               if(!st.empty() && st.top()->left == p){
                   p = st.top()->right;
               }
               //是右子，接下来该访问父亲结点
               else{
                   p = NULL;
               }
           }
       }
   }
   ~~~

4. 给出二叉树的自下而上，自右到左的层次遍历算法。

   **思路:**

   用一个栈存放从上到下从左到右层次遍历的结果，然后依次弹栈，就刚好是所要求的自下而上，自右到左的层次遍历过程。

   **代码:**

   ~~~c++
   void Level(BiTree T){
       if(T == NULL)
           return;
       queue<BiTree> qu;
       stack<BiTree> st;
       qu.push(T);
       while(!qu.empty()){
           int size = qu.size();
           for(int i = 0; i < size; i++){
               BiTree p = qu.front();
               qu.pop();
               st.push(p);
               if(p->left){
               	qu.push(p->left)   
               }
               if(p->right){
                   qu.push(p->right);
               }
           }
       }
       while(!st.empty()){
           visit(st.top()->val);
           st.pop();
       }
   }
   ~~~

5. 假设二叉树使用二叉链表存储结构，设计一个非递归算法求二叉树的高度。

   **思路:**

   递归算法也好写，不递归算法则是采用层次遍历的思路，每遍历一层就令高度自增。

   **代码:**

   ~~~c++
   int height(BiTree T){
       if(T == NULL)
           return;
       queue<BiTree> qu;
       int height = 0;
       qu.push(T);
       while(!qu.empty()){
           height++;
           int size = qu.size();
           for(int i = 0; i < size; i++){
               BiTree p = qu.front();
               qu.pop();
               if(p->left){
               	qu.push(p->left)   
               }
               if(p->right){
                   qu.push(p->right);
               }
           }
       }
       return height;
   }
   ~~~

6. 设一棵二叉树中各结点的值互不相同，其先序遍历序列和中序遍历序列分别存在两个一维数组A[1...n]中和B[1...n]中，试编写算法建立该二叉树的二叉链表。

   **思路:**

   先序遍历的第一个元素必是根元素，然后在中序遍历的数组中找到这个元素，在这个元素的左边的元素属于该元素的左子树，右边的元素属于该元素的右子树，之后对左子树和右子树分别采用同样的算法，可以用递归的方式来实现。

   **代码:**

   ~~~c++
   BiTree* ConstructTree(int A[n+1], int B[n+1], int Aleft, int Aright, int Bleft, int Bright){
       if(Aleft > Aright || Bleft > Bright){
           return NULL;
       }
       BiTree *root = new BiTree();
       int i = Bleft;
       while(i <= Bright && B[i] != A[Aleft]){
           i++;
       }
       root->val = B[i];
       //[Aleft+1, Aleft+(i-1)]是左子树在先序数组A中的位置
       //[Bleft  , i-1]        是左子树在中序数组B中的位置
       root->left = ConstructTree(A,B,Aleft+1,Aleft+i-1,Bleft,i-1);
       //[Aleft+i, Aright]     是右子树在先序数组A中的位置
       //[i+1    , Bright]     是右子树在中序数组B中的位置
       root->right = ConstructTree(A,B,Aleft+i,Aright,i+1,Bright);
       return root;
   }
   ~~~

7. 二叉树按二叉链表形式存储，写一个判别给定二叉树是否为完全二叉树的算法。

   **思路:**

   采用层次遍历，对结点进行判断，如果该结点不是同时拥有左右孩子时，说明可能到达了倒二层；进一步判断该节点是否有右孩子无左孩子，如果是，则该树不是完全二叉树；如果该结点既无左孩子也无右孩子，或有左孩子无右孩子，则本层该节点后的结点，以及最后一层的所有结点全都应该为叶节点。

   **代码:**

   ~~~c++
   bool isComplete(BiTree T){
       if(T == NULL)
           return true;
       queue<BiTree> qu;
       qu.push(T);
       bool islast = false;
       //不是最后一层
       while(!qu.empty() && !islast){
           int size = qu.size();
           int i = 0;
           while(i < size){
               BiTree p = qu.front();
               qu.pop();
               //同时有左右孩子
               if(p->left && p->right){
               	qu.push(p->left);
                   qu.push(p->right);
                   i++;
               }
               //有右孩子无左孩子
               else if(p->right && !p->left){
                   return false;
               }
               //无左右孩子，或者有左孩子无右孩子，则下一层是最后一层
               else{
                   islast = true;
                   break;
               }
           }
       }
       //本层剩余的，以及最后一层的所有元素，均为叶节点
       while(!qu.empty()){
           BiTree p = qu.front();
           qu.pop();
           if(p->left || p->right){
               return false;
           }
       }
       return true;
   }
   ~~~

8. 假设二叉树采用二叉链表存储结构存储，设计一个算法，计算一棵给定二叉树的所有双分支结点个数。

   **思路:** 层次遍历，把所有有双分支的结点个数记录下来。

   **代码:**

   ~~~c++
   int Dbcount(BiTree root){
       if(T == NULL)
           return 0;
       queue<BiTree> q;
       q.push(root);
       int count = 0;
       while(!q.empty()){
           int size = q.size();
           for(int i = 0; i < size; i++){
               BiTree p = q.front();
               q.pop();
               if(p->left){
                   q.push(p->left);
               }
               if(p->right){
                   q.push(p->right);
               }
               if(p->left && p->right){
                   count++;
               }
           }
       }
       return count;
   }
   ~~~

9. 设树B是一棵采用链式结构存储的二叉树，编写一个把树B中所有节点的左右子树进行交换的函数。

   **思路:** 递归完成

   **代码:**

   ~~~c++
   void Swap(BiTree &T){
       if(T != NULL){
           Swap(T->left);
           Swap(T->right);
           BiTree = T->left;
           T->left = T->right;
           T->right = BiTree;
       }
   }
   ~~~

10. 假设二叉树采用二叉链表存储结构存储，设计一个算法求先序遍历中第k(i<=k<=二叉树中节点个数)个结点的值。

    **思路:** 直接先序序列遍历，把值存入一个数组里，然后找到数组的第[k-1]个元素(数组从0开始)。(<font color = red>题解有更漂亮的方法</font>)

    **代码:** 略

11. 已知二叉树以二叉链表存储，编写算法完成：对于树种每个元素值为x的结点，删去它为根的子树并释放相应的空间。

    **思路:** 先序遍历二叉树，当遇到值为x的结点时，删除它的所有孩子。（答案好像好复杂？）

    **代码:**

    ~~~c++
    void PreOrder(BiTree &T, ElemType x){
        if(T == NULL)
            return;
        if(T->val == x){
            Delete(T->left);
            Delete(T->right);
        	return;
        }
        else{
        	PreOrder(T->left);
        	PreOrder(T->right);
    	}
    }
    
    void Delete(BiTree &T){
        if(T){
            Delete(T->left);
            Delete(T->right);
    	    delete(T);
        }
    }
    ~~~

12. 在二叉树中查找值为x的结点，试编写算法(用C语言)打印值为x的结点的所有祖先，假设值为x的结点不多于一个。

    **思路:** 用栈存储，然后**后序遍历**二叉树，找到值为x的结点。

    **代码:**

    ~~~c++
    void PrintAncestors(BiTree T, ElemType x){
        if(T == NULL)
            return;
        bool isfind = false;
        stack<BiTree> s;
        BiTree p = T;
        while(!s.empty() || p){
        	if(p){
               	if(p->val == x){
                	isfind = true;
                   	break;
               	}
               	s.push(p);
               	if(p->left)
            		p = p->left;
                else
                    p = p->right;
            }
            else{
                p = s.top();
                s.pop();
                //判断p是栈顶元素的左子树还是右子树
                //p是栈顶元素的左子树，试着遍历右子树
                if(!s.empty() && s.top()->left == p){
                    p = s.top()->right;
                }
                //是右子树，左子树已经遍历完毕了
                else{
                    p = NULL;
                }
            }
        }
        if(isfind){
            int i = 0;
            while(!s.empty()){
                ElemType Arr[10000];
                Arr[i++] = s.top()->val;
                s.pop();
            }
            i--;
            while(i>=0){
                cout<<Arr[i--]<<endl;
            }
        }
    }
    ~~~

13. 设一棵二叉树结点结构分别为(LLINK,INFO,RLINK)，ROOT为指向该二叉树根结点的指针，p和q分别为指向该二叉树中任意两个结点的指针，试编写ANCESTOR(ROOT,p,q,r)，找到p和q的最近公共祖先结点r。

    **思路:** 可以用递归的方式实现(课本里的答案也太复杂了……)

    **代码:**

    ~~~c++
    void ANCESTOR(TreeNode *root, TreeNode *p, TreeNode *q, TreeNode *r){
        r = Ancestor(root,p,q);
    }
    
    TreeNode *Ancestor(TreeNode *root, TreeNode *p, TreeNode *q){
        //找到p，或者找到q，或者访问到了空指针，返回结果
        if(root == NULL || root == q || root == p){
            return root;
        }
        //p或q可能在左边
        TreeNode *left = Ancestor(root->left,p,q,r);
        //p或q也可能在右边
        TreeNode *right = Ancestor(root->right,p,q,r);
        //p,q均不在该结点的左右分支里
        if(left == NULL && right == NULL)
            return NULL;
        //左边p和q都找不到，那p和q就在右边
        if(!left){
            return right;
        }
        //右边p和q都找不到，那p和q只能在左边
        if(!right){
            return left;
        }
        //左边能找到p或q，右边也能找到p或q，说明p和q分别在该结点的左右子树里，那么该结点就是最近公共祖先
        return root;
    }
    ~~~

14. 假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树b的宽度(即具有结点数最多的那一层的结点个数)。

    **思路:** 层次遍历，记录每层的宽度，找出最大的宽度

    **代码:**

    ~~~c++
    int width(BiTree T){
    	int c = 0;
        if(T == NULL)
            return c;
        queue<BiTree> q;
        q.push(T);
        while(!q.empty()){
            int size = q.size();
            c = max(c, size);
            for(int i = 0; i < size; i++){
                BiTree p = q.front();
                q.pop();
                if(p->left)
                    q.push(p->left);
                if(p->right)
                    q.push(p->right);
            }
        }
        return c;
    }
    ~~~

15. 设有一棵满二叉树(所有结点值均不同)，已知其先序序列为pre，设计一个算法求其后序序列post。

    **思路:** 由于是满二叉树，其任意非叶结点的子树也是满二叉树，因此每次找出根节点后，可以从根节点的左右子树递归构建后序遍历的序列

    **代码:**

    ~~~c++
    //执行PostOrderSeq(preorder, 0, n-1)即可得到后序遍历的结果(保存在p)
    void PostOrderSeq(ElemType &PreOrder[n], int left, int right){
        //递归构建左子树的后序序列
        PostOrderSeq(PreOrder, left+1, left+(right-left)/2);
    	//递归构建右子树的后序
        PostOrderSeq(PreOrder, left+(right-left)/2+1, right);
        //把根结点放到构建完后的末尾
        ElemType q = PreOrder[left];
        for(int i = left; i < right - 1; i++){
            PreOrder[i] = PreOrder[i+1];
        }
        PreOrder[right] = q;
    }
    ~~~

16. 设计一个算法将二叉树的叶节点按从左到右的顺序连成一个单链表，表头指针为head。二叉树按二叉链表的方式存储，链接时用叶节点的右指针域存放单链表指针。

    **思路:** 用非递归的方式来先序遍历链表，优先向左搜索，用一个哨兵变量存储上一个结点。

    **代码:**

    ~~~c++
    Linklist *LinkTree(BiTree T, Linklist *head){
        stack<BiTree> s;
        BiTree p = T;
        Linklist *q = head;
        while(!s.empty() || p){
            if(p){
                s.push(p);
                p = p->left;
            }
            else{
                p = s.top();
                s.pop();
                //判断是否为叶节点
                if(!p->left && !p->right){
                	q->right = p;
                	q = q->next;
            	}
            	p = p->right;
            }
        }
        q->right = NULL;
        return head;
    }
    ~~~

17. 

    **思路:**题目定义就是递归定义啊……

    **代码:**

    ~~~c++
    bool isSimilar(BiTree A, BiTree B){
        //都为空，相似
        if(A == NULL && B == NULL)
            return true;
        //只有一个为空，不相似
        if(A == NULL || B == NULL)
            return false;
        //递归比较左右子树相似不相似
        bool left = isSimilar(A->left, B->left);
        bool right = isSimilar(A->right, B->right);
        return left && right;
    }
    ~~~

18. 题目说的啥玩意啊

    **思路:**

    **代码:**

19. 

    **思路:**非递归方式，**后序遍历**二叉树，用栈存储路径，用一个变量存储总权值，一个变量存储当前路径的深度，每次遇到叶节点，计算权值并加到总权值里。

    注意，二叉树的带权路径长度是每个叶子结点的深度-1（从根节点到叶子结点所经过的边的个数）和其权值之积的总和。

    **代码:**

    ~~~c++
    int WPL(BiTree T){
        int total_weight = 0;
        int deep = 0;
        stack<int> s;
        BiTree p = T;
        while(!s.empty() || p){
        	if(p){
                s.push(p);
                deep++;
                if(p->left)
                	p = p->left;
                else
                    p = p->right;
            }
            else{
                p = s.top();
                s.pop();
                //判断是否为叶节点，如果是，计算权值
                if(!p->left && !p->right)
                	total_weight += (deep-1) * p->weight;
                //观察最近一个结点与其父亲结点的关系
                //是父亲的左子，还要试着访问父亲的右子
                if(!s.empty() && s.top()->left == p){
                    p = s.top()->right;
                }
                //是右子，接下来该访问父亲结点
                else{
                    p = NULL;
                }
                deep--;
            }
            
        }
        return total_weight;
    }
    ~~~

20. 

    **思路:**递归的方式遍历二叉树，向左遍历时先往最左边增加一个括号，向右边遍历时往最右边增加一个括号，最后打印时候记得去掉最左边和最右边的括号即可。

    **代码:**

    ~~~c++
    String inOrder(BiTree T){
        if(T == NULL)
            return "";
        if(T->left == NULL && T->right == NULL)
            return T->val;
        String left = "(" + inOrder(T->left);
        String right = inOrder(T->right) + ")";
        return left + T->data + right;
    }
    
    void PrintTree(BiTree T){
        String ans = inOrder(T);
        //去掉最左和最右的括号
        for(int i = 1; i < ans.size()-1; i++){
            cout<<ans[i];
        }
    }
    ~~~

### 5.4 树，森林(page 170)

5. 

   **思路:**叶子节点即为无左右孩子的结点，也就是在树中，没有左孩子的结点就是森林中的叶节点。

   **代码:**

   ~~~c++
   int countLeaves(CSNode T){
       int count = 0;
       stack<CSNode> s;
       CSNode p = T;
       while(!s.empty() || p){
           if(p){
               s.push(p);
               p = p->firstchild;
           }
           else{
               p = s.top();
               s.pop();
               if(!p->firstchild){
                   count++;
               }
               p = p->nextsibling;
           }
       }
       return count;
   }
   ~~~

6. 

   **思路:**如果有左孩子，就递归求左孩子的最大深度，如果有右兄弟，就递归求右兄弟的最大深度

   **代码:**

   ~~~c++
   int height(CSNode T){
       if(T == NULL)
           return 0;
       int left = height(T->firstchild) + 1;
       int right = height(T->nextsibling);
       return max(left,right);
   }
   ~~~

7. 

   **思路:**用一个指针A存储当前结点，用一个指针B指向该结点的孩子结点，由于层次遍历的结果存放在数组中，在完成当前结点的构建后，指针A后移，指针B指向的一定是下一个度不为0的结点的孩子结点。

   **代码:**

   ~~~c++
   //levelSq指层级遍历序列数组，Degrees指每个结点的度数组
   CSNode constructCSTree(ElemType levelSq[], int Degrees[], int n){
       CSNode *Pointers = new CSNode[n];
       for(int i = 0; i < n; i++){
           Pointers[i]->val = levelSq[i];
           Pointers[i]->firstchild = NULL;
           Pointers[i]->nextsibling = NULL;
       }
       int pointerA = 0, pointerB = 0;
       while(pointerA < n){
           if(Degrees[pointerA] > 0){
               pointerB++;
               Pointers[pointerA]->lchild = Pointers[B];
               for(int j = 2; j <= Degrees[pointerA]; j++){
                   B++;
                   Pointers[B-1]->nextsibling = Pointers[B];
               }
           }
           pointerA++;
       }
       return Pointers[0];
   }
   ~~~

   ### 5.5 树与二叉树的应用(page 182)
   
   6. 
   
      **思路:**可以中序遍历该树，并记录上一个遍历的值，当出现的值小于上一个出现的值时就不是二叉排序树
   
      **代码:**
   
      ~~~c++
      //初始化pre为INT_MIN
      bool isBST(BiTree T, int &pre){
      	if(T == NULL)
              return true;
          bool left = isBST(T->left, pre);
          if(!left || pre > T->val){
              return false;
          }
          pre = T->val;
          bool right = isBST(T->right, pre);
          return right;
      }
      ~~~
   
   7. 
   
      **思路:**用一个变量存储深度，设一个指针p指向根节点，如果p不为node，且p比node的值大，就往左边找，否则往右找，直到找到node或p为空为止。
   
      **代码:**
   
      ~~~c++
      int BSTNodeLevel(BiTree T, BiTree node){
          if(!T){
              return -1;
          }
          int level = 0;
          BiTree p = T;
          while(p && p != node){
              if(p->val > node->val){
                  p = p->left;
              }
              else{
                  p = p->right;
              }
          }
          return p == NULL ? -1 : level + 1;
      }
      ~~~
   
   8. 
   
      **思路:**二叉树遍历的思想与递归密不可分，可以判断左子树是否平衡，再判断右子树是否平衡，比较左右子树的深度，得到结论。
   
      **代码:**
   
      ~~~c++
      int isBalance(BiTree T){
          if(T == NULL){
              return 0;
          }
          int left = isBalance(T->left);
          int right = isBalance(T->right);
          //左子树或右子树不平衡，则以其父亲结点作为根节点的树不平衡
          if(left == -1 || right == -1){
              return -1;
          }
          //左右子树都平衡，但左右子树深度差的绝对值大于1，则以其父节点作为根节点的树不平衡
          if(left - right < -1 || left - right > 1){
              return -1;
          }
          return left > right ? left+1 : right+1;
      }
      ~~~
   
   9. 
   
      **思路:**最左结点和最右结点就是最小和最大的关键字
   
      **代码:**
   
      ~~~c++
      int minBST(BiTree T){
          if(T == NULL){
              return INT_MIN;
          }
          BiTree p = T;
          while(p->left)
              p = p->left;
          return p->val;
      }
      
      int maxBST(BiTree T){
          if(T == NULL){
              return INT_MIN;
          }
          BiTree p = T;
          while(p->right)
              p = p->right;
          return p->val;
      }
      ~~~
   
   10. 
   
       **思路:**采用中序遍历，但要改成右->根->左的方式，遇到值小于k的结点时，停止遍历。
   
       **代码:**
   
       ~~~c++
       void PrintKeyInBST(BiTree T){
           if(T == NULL)
               return;
           PrintKeyInBST(T->right);
           if(T->val < k)
               return;
           cout<<T->val<<endl;
           PrintKeyInBST(T->left);
       }
       ~~~
   
   12. 
   
       **思路:**类似于二分查找的改良，利用当前节点的左子树的count，可以得知当前结点值的相对排名。
   
       **代码:**
   
       ~~~c++
       BiTree BSTKthMin(BiTree T, int k){
           if(T == NULL || k < 1 || k > T->count)
               return NULL;
           if(T->left){
               if(T->left->count == k-1){
                   return T;
               }
               else if(T->left->count < k-1){
               	return BSTKthMin(T->right, k-1-T->left->count)
               }
               else{
                   return BSTKthMin(T->left, k);
               }
           }
           else if(k == 1){
               return T;
           }
           return BSTKthMin(T->right, k-1);
       }
       ~~~



## 第6章 图

### 6.1 图的基本概念(page 208)

### 6.2 图的存储及基本操作(page 216)

4. 写出从图的邻接表表示转换成邻接矩阵表示的算法

   **思路:**根据定义转换即可。

   **代码:**

   ~~~c++
   MGraph ALGraph_to_MGraph(ALGraph g){
       MGraph m;
       m.vexnum = g.vexnum;
       m.arcnum = g.arcnum;
       for(int i = 0; i < g.vexnum; i++){
           m.Vex[i] = g.vertices[i].data;
           ArcNode p = g.vertices[i].first;
           while(p){
               m.Edge[i][p->adjvex] = 1;
               p = p->next;
           }
       }    
       return m;
   }
   ~~~

### 6.3 图的遍历(page 226)

2. 设计一个算法判断一个无向图G是否为一棵树。若是一棵树，则算法返回true，否则返回false。

   <font color = red>**思路:**图有n-1条边，且为连通图，即为树，否则不为树。</font>

   **代码:**

   ~~~c++
   bool isTree(Graph g){
       int edge_num = 0;
       bool visited[MAX_VEXTEX_NUM];
       for(int i = 0; i < g.vexnum; i++){
           visited[i] = false;
       }
       DFS(g,visited,edge_num,0);
       for(int i = 0; i < g.vexnum; i++){
           if(!visited[i]) return false;
       }
       return edge_num == n-1;
   }
   
   void DFS(Graph &g, bool &visit[MAX_VEXTEX_NUM], int &edge_num, int v){
       visit[v] = true;
       edge_num++;
       for(int w = FirstNeighbor(G,v); w >= 0; w = NextNeighbor(G,v,w)){
           if(!visit[w]) DFS(g,visit,edge_num,w);
       }
   }
   ~~~

3. 写出图的深度优先搜索DFS算法的非递归算法(图采用邻接表形式)。

   **思路:**采用栈记忆下一步可能访问的顶点，使用一个标记数组记录第i个顶点是否被访问过，注意到这里的深度遍历是从顶点在邻接表内的最后一个邻居节点逐步深入访问。

   **代码:**

   ~~~c++
   void DFS(Graph g){
       bool visited[MAX_VEXTEX_NUM];
       for(int i = 0; i < g.vexnum; i++){
           visited[i] = false;
       }
       stack<int> s;
       for(int i = 0; i < g.vexnum; i++){
           if(!visited[i]){
               s.push(i);
               visited[i] = true;
               while(!s.empty()){
                   int t = s.top();
                   s.pop();
                   for(int w = FirstNeighbor(G,t); w >= 0; w = NextNeighbor(G,t,w)){
                       if(!visited[w]){
                           s.push(w);
                           visited[w] = true;
                       }
                   }
               }
           }
       }
   }
   ~~~

4. 分别采用基于深度优先遍历和广度优先遍历算法判别以邻接表方式存储的有向图中是否存在由顶点v<sub>i</sub>到顶点v<sub>j</sub>的路径(i≠j)。注意，算法中涉及的图的基本操作必须在此存储结构上实现。

   **思路:**思路其实就是图的深度优先搜素和广度优先搜索，区别在于判断存在顶点i到j的路径只需要让起点为i即可。

   **代码:**

   ~~~c++
   bool DFS(Graph p, bool &visited[MAX_VEXTEX_NUM], int i, int j){
       if(v == j)
           return true;
       visited[i] = true;
       bool result = false;
       for(int k = FirstNeighbor(G,i); k >= 0; k = NextNeighbor(G,i,k)){
           if(!visited[k]){
               result = result || DFS(p, visited, k, j);
           }
       }
       return result;
   }
   
   bool BFS(Graph p, bool &visited[MAX_VEXTEX_NUM], int i, int j){
       queue<int> q;
       q.push(i);
       while(!q.empty()){
           int t = q.front();
           if(t == j)
               return true;
           visited[t] = true;
           q.pop();
           for(int w = FirstNeighbor(G,t); w >= 0; w = NextNeighbor(G,t,w)){
          		if(!visited[w]){
                   p.push(w);
               }
           }
       }
       return false;
   }
   ~~~

5. 假设图用邻接表表示，设计一个算法，输出顶点V<sub>i</sub>到顶点V<sub>j</sub>的所有简单路径。

   **思路:**使用回溯法，用一个数组存放路径点，找到Vj时，将数组里的所有元素输出一次。

   **代码:**

   ~~~c++
   void DFS(Graph p, int &visited[MAX_VEXTEX_NUM], int &route[MAX_VEXTEX_NUM], int length, int i, int j){
       if(i == j){
           for(int t = 0; t < length; t++){
               cout<<route[t]<<" ";
           }
           cout<<j<<endl;
           return;
       }
       for(int w = FirstNeighbor(G,i); w >= 0; w = NextNeighbor(G,i,w)){
           if(!visited[w]){
               visited[w] = true;
               DFS(p, visited, route, length + 1, w, j);
           	visited[w] = false;
           }
       }
   }
   ~~~

### 6.4 图的应用(page 238)



## 第7章 查找

### 7.1 查找的基本概念(page 270)

3. 类比二分查找算法，设计k分查找算法。

   **思路:**

   **代码:**

6. 写出折半查找的递归算法，初始调用时，low为1，high为ST.length

   **思路:**

   **代码:**

7. 线性表中各结点的检索概率不等时，可以采用如下策略提高顺序检索的效率：若找到指定的结点，则将该结点和其前驱结点(若存在)交换，使得经常被检索的结点尽量位于表的前端。试设计在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。

   **思路:**

   **代码:**

### 7.2 顺序查找和折半查找(page 271)

### 7.3 B树和B+树(page 284)

### 7.4 散列表(page 295)



