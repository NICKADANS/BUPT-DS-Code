# 数据结构(应用题及代码)

## 第2章 线性表

### 2.2 线性表的顺序表示(Page 19)

1. 从顺序表中删除具有最小值的元素(假设唯一)，并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。

   **思路**:步骤1.查找最小元素 步骤2.用最后一个元素填补删除的元素(除非删除的是最后一个元素)

   **代码**:

   ~~~ c++
   bool Del_Min(SqList &L, ElemType &value){
       if(L.length == 0)
           return false;
       int min_index = 0;
       value = L.data[0];
       for(int i = 1; i < L.length; i++){
   		if(L.data[i] < L.data[min_index]){
               min_index = i;
           	value = L.data[i];
           }
       }
       //这是一处我认为题目可能有bug的地方：当删除最后一个元素的时候，空出的位置不应该有元素填补
       if(min_index == L.length-1){
           L.data[min_index] = L.data[length];
       	return true;
       }
       L.data[min_index] = L.data[L.length-1];
       L.length--;
       return true;
   }
   ~~~

2. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。

   **思路**:通过一个辅助变量temp来交换首尾两个元素，然后交换第二个和倒二个元素，然后交换第三个倒三个元素……以此类推

   **代码**:

   ~~~c++
   void Reverse(SqList &L){
       ElemType temp;
       for(int i = 0; i < L.length/2; i++){
           temp = L.data[i];
           L.data[i] = L.data[L.length-1-i];
           L.data[L.length-1-i] = temp;
       }
   }
   ~~~

3. 对长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。

   **思路**:用k记录顺序表L中不等于x的元素个数(即需要保存的元素个数)，边扫描边统计k，并将不等于x的元素挪动到第k个位置，最后修改L的长度

   **代码**:

   ~~~c++
   void del_x_1(SqList &L, ElemType x){
       int k = 0;
       for(int i = 0; i < L.length; i++){
           if(L.data[i] != x){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
   }
   ~~~

4. 从有序顺序表中删除其值在给定s与t之间(要求s<t)的所有元素，如果s或t不合理或顺序表为空，则显示出错信息并退出运行。

   **思路**:首先判断s与t是否合理或顺序表是否为空。观察到顺序表是“有序”的，可以用二分搜索找到第一个大于等于s的值的位置pos1以及第一个大于t的值的位置pos2，将pos2之后的值挪动到pos1之后，更新L的长度

   **代码**:

   ~~~c++
   bool Del_s_t2(SqList &L, ElemType s, ElemType t){
       if(s >= t || L.length == 0){
           return false;
       }
       int pos1 = -1, pos2 = L.length;
       //为了省事就不用二分搜索确定pos1和pos2了，直接用遍历确定
       for(int i = 0; i< L.length; i++){
           if(L.data[i] < s){
               pos1 = i;
           }
           if(L.data[i] > t){
               pos2 = i;
               break;
           }
       }
       pos1 += 1;//第一个大等于s的位置
       //用pos2及之后的值覆盖pos1到pos2-1之间的的值
       while(pos2 < L.length){
           L.data[pos1] = L.data[pos2];
           pos1++;
           pos2++;
       }
       L.length = pos1;
       return true;
   }
   ~~~

5. 从顺序表中删除其值在给定值s与t之间(包含s和t，要求s<t)的所有元素，如果s或t不合理或顺序表为空，则显示出错信息并退出运行。

   **思路**:用k记录顺序表L中值不在s与t之间的元素个数(即需要保存的元素个数)，边扫描边统计k，令值不在s与t之间的元素挪动到第k个位置，最后修改L的长度

   **代码**:

   ~~~ c++
   bool Del_S_t(SqList &L, ElemType s, ElemType t){
       if(s >= t || L.length == 0){
           return false;
       }
       int k = 0;
       for(int i = 0; i < L.length; i++){
           if(L.data[i] < s || L.data[i] > t){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
       return true;
   }
   ~~~

6. 从有序顺序表中删除其值重复的元素，使表中所有的元素值均不同。

   **思路**:由于数组是有序的，则重复的数必定连续出现，用k记录有序表中值不重复的元素个数，之后边扫描边统计k，当遇到的元素重复时，则跳过，否则将位于k位置的元素更新为当前元素，并增加k的值

   **代码**:

   ~~~c++
   void Delete_Same(SqList &L){
       if(L.length == 1){
           return;
       }
       int k = 1;
       for(int i = 1; i < L.length; i++){
           if(L.data[i] != L.data[k-1]){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
   }
   ~~~

7. 将两个有序顺序表合成为一个新的有序顺序表，并由函数返回结果顺序表。

   **思路**:假定两个顺序表是顺序递增的，使用两个指针i和j分别指向两个表的第一个元素，每次比较中挑选较小的元素放入新表，相应指针向前移动，当其中一根指针到达表的末端时，将另一张表的剩余元素都放入新表中。

   **代码**:

   ~~~c++
   bool Merge(SqList &A, SqList &B, SqList &C){
       if(A.length + B.length > C.maxSize){
           return false;
       }
       int i = 0, j = 0, k = 0;
       while(i < A.length && j < B.length){
           if(A[i] < B[j]){
               C[k++] = A[i++];
           }
           else{
               C[k++] = B[j++];
           }
       }
       while(i < A.length){
           C[k++] = A[i++];
       }
       while(j < B.length){
           C[k++] = B[j++];
       }
       C.length = A.length + B.length;
       return true;
   }
   ~~~

8. 已知在一维数组A[m+n]中依次存放两个线性表(a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>m</sub>)和(b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,...,b<sub>n</sub>)，试编写一个函数，将数组中两个顺序表的位置互换，即(b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,...,b<sub>n</sub>)放在(a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>m</sub>)的前面。

   <font color=red>**思路**</font>:<font color = blue>先把A数组倒过来，即令A[m+n] = (a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>m</sub>,b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,...,b<sub>n</sub>)倒转为A[n+m] = (b<sub>n</sub>,b<sub>n-1</sub>,b<sub>n-2</sub>,...,b<sub>1</sub>,a<sub>m</sub>,a<sub>m-1</sub>,a<sub>m-2</sub>,...,a<sub>1</sub>)，然后再分别对n和m部分分别进行倒转，得到结果</font>

   **代码**:

   ~~~c++
   void Exchange(DataType &A[], int m, int n, int arraySize){
       Reverse(A, 0, m+n-1, arraySize);
       Reverse(A, 0, n-1, arraySize);
       Reverse(A, n, m+n-1, arraySize);
   }
   
   void Reverse(DataType &Arr[], int left, int right, int arraySize){
       if(left >= right || right >= arraySize){
           return;
       }
       DataType temp;
       for(int i = 0; i < (right-left+1)/2; i++){
           temp = Arr[left+i];
           Arr[left+i] = Arr[right-i];
       	Arr[right-i] = temp;
       }
   }
   ~~~

9. 线性表(a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,...,a<sub>n</sub>)中的元素递增有序且按顺序存储于计算机内，要求设计一算法，完成用最少时间在表中查找数值为x的元素，若找到则将其与后继元素位置相交换，若找不到则将其插入表中，并使表中元素仍递增有序。

   **思路**:首先用二分查找找到x的位置(或第一个大于x的位置)，然后将x插入或交换

   **代码**:

   ~~~c++
   void SerarchExchangeInsert(SqList &A, ElemType x){
       int pos = BinarySearch(A, x, 0, A.length-1);
       //找到该元素，进行交换
       if(A.data[pos] == x){	
           ElemType temp = A.data[pos];
           A.data[pos] = A.data[pos+1];
           A.data[pos+1] = temp;
       }
       //未找到该元素，进行插入
       else{	
   		A.length++;
           for(int i = A.length; i > pos; i--){
               A.data[i] = A.data[i-1];
           }
           A.data[pos] = x;
       }
   }
   
   int BinarySearch(SqList A, ElemType x, int left, int right){
       int mid = (left+right)/2;
       while(left <= right){
           if(A.data[mid] == x){
               return mid;
           }
           else if(A.data[mid] > x){
               right = mid - 1;
           }
           else{
               left = mid + 1;
           }
       }
       return left;
   }
   ~~~

10. (2010统考真题)设将n(n>1)个整数存放到一维数组R中，设计一个在时间和空间两方面都尽可能高效的算法，将R中保存的序列循环左移p(0<p<n)个位置，即将R中的数据由(X<sub>0</sub>,X<sub>1</sub>,...,X<sub>n-1</sub>)变换为(X<sub>p</sub>,X<sub>p+1</sub>,...,X<sub>n-1</sub>,X<sub>0</sub>,X<sub>1</sub>,...,X<sub>p-1</sub>)。

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:题目要求将R中的数据由(X<sub>0</sub>,X<sub>1</sub>,...,X<sub>p-1</sub>,X<sub>p</sub>,X<sub>p+1</sub>,...X<sub>n-1</sub>)变换为(X<sub>p</sub>,X<sub>p+1</sub>,...,X<sub>n-1</sub>,X<sub>0</sub>,X<sub>1</sub>,...,X<sub>p-1</sub>)，令(X<sub>0</sub>,X<sub>1</sub>,...,X<sub>p-1</sub>)为a，(X<sub>p</sub>,X<sub>p+1</sub>,...X<sub>n-1</sub>)为b，则题目要求将数组R = {a,b}变为 {b,a}。首先将R逆转为R<sup>-1</sup>={b<sup>-1</sup>,a<sup>-1</sup>}，然后再对R<sup>-1</sup>中的b<sup>-1</sup>和a<sup>-1</sup>各自逆转，即可得到答案{b,a}。(思路同第8题)

    **代码**:

    ~~~c++
    void Exchange(DataType &A[], int m, int n, int arraySize){
        Reverse(A, 0, m+n-1, arraySize);
        Reverse(A, 0, n-1, arraySize);
        Reverse(A, n, m+n-1, arraySize);
    }
    
    void Reverse(DataType &Arr[], int left, int right, int arraySize){
        if(left >= right || right >= arraySize){
            return;
        }
        DataType temp;
        for(int i = 0; i < (right-left+1)/2; i++){
            temp = Arr[left+i];
            Arr[left+i] = Arr[right-i];
        	Arr[right-i] = temp;
        }
    }
    ~~~

    **复杂度分析**:时间复杂度O(n)，空间复杂度O(1)

11. (2011统考真题)一个长度为L(L>=1)的升序序列S，处在第L/2(向上取整)个位置的数称为S的中位数，例如，若序列S<sub>1</sub>=(11,13,15,17,19)，则15为S<sub>1</sub>的中位数，两个序列的中位数是含它们所有元素的升序序列的中位数，例如，若S<sub>2</sub>=(2,4,6,8,20)，则S<sub>1</sub>和S<sub>2</sub>的中位数是11，现在有两个等长升序序列A和B，试设计一个在时间和空间上都尽可能高效的算法，找出两个序列A和B的中位数。

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:分别求出A的中位数a和B的中位数b。当a=b时，则中位数就为a或b；当a<b，令A舍弃a之前的部分成为A'，令B舍弃b之后的部分成为B'，然后求A'和B'的中位数；当a>b，令A舍弃a之后的部分成为A'，令B舍弃b之前的部分成为B'，然后求A'和B'的中位数。重复上述过程，直到a=b，或者A'的元素或B'的元素只剩一个时，较小的那个数即为中位数

    <font color = red>**代码**</font>:

    <font color = red>思路易得，但代码很容易出bug!</font>

    ~~~c++
    int M_Search(int A[], int B[], int n){
        int a_left = 0, a_right = n-1, b_left = 0, b_right = n-1;
        int a_mid, b_mid;
        while(a_left < a_right && b_left < b_right){
            a_mid = (a_left+a_right)/2;
            b_mid = (b_lett+b_right)/2;
            if(A[a_mid] == B[b_mid]){
                return A[a_mid];
            }
            else if(A[a_mid] < B[b_mid]){
                //元素个数为偶数，舍弃A中点以前的数(包含中点)，B中点以后的数(不包含中点)
                if((a_right-a_left+1) % 2 == 0){
                    a_left = a_mid + 1;
                    b_right = b_mid;
                }
                //元素个数为奇数，舍弃A中点以前的数(不包含中点)，B中点以后的数(不包含中点)
                else{
                	a_left = a_mid;
                	b_right = b_mid;
            	}
            }
            else{
                //元素个数为偶数，舍弃A中点以后的数(不包含中点)，B中点以前的数(包含中点)
                if((a_right-a_left+1) % 2 == 0){
                    b_left = b_mid + 1;
                    a_right = a_mid;
                }
                //元素个数为奇数，舍弃A中点以后的数(不包含中点)，B中点以前的数(不包含中点)
                else{
                    b_left = b_mid;
                	a_right = a_mid;
                }
            }
        }
        return A[a_left] < B[b_left] ? A[a_left] : B[b_left];
    }
    ~~~

    **复杂度分析**:时间复杂度O(logN)，空间复杂度O(1)

12. (2013统考真题)已知一个整数序列A=(a<sub>0</sub>,a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n-1</sub>)，其中0<=a<sub>i</sub><n(0<=i<n)。若存在a<sub>p<sub>1</sub></sub>=a<sub>p<sub>2</sub></sub>=...=a<sub>p<sub>m</sub></sub>=x且m>n/2 (0<=p<sub>k</sub><n, 1<=k<=m)，则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5)，则5为主元素；又如A=(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的n个元素保存在一维数组中，请设计一个尽可能高效的算法，找出A的主元素，若存在主元素，则输出该元素；否则输出-1。

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    <font color = red>**思路**</font>:主元素的定义其实就是出现次数超过数组长度一半的元素，如果出现次数超过一半，那这个元素必定唯一，且至少在数组的某一处连续出现过两次，我们就从这个入手，标记出一个可能成为主元素的元素Num，然后重新计数，最终确定Num是否为主元素。

    算法分为以下两步：
    
    ①.选取侯选主元素，依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数重新加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述流程，直到扫描完全全部数组元素。
    
    ②.判断c中元素是否为真的主元素，再次扫描该数组，统计c中元素出现的次数，若大于n/2，则为主元素，否则序列中不存在主元素。
    
    <font color = red>最优思路难得，次优思路很容易想到</font>
    
    **代码**:
    
    ~~~c++
    int Majority(int A[], int n){
        if(n < 1){
            return -1;
        }
        if(n == 1){
            return A[0];
        }
        int result = A[0], count = 1;
        for(int i = 1; i < n; i++){
            if(A[i] == result){
                count++;
            }
            else{
                count--;
                if(count == 0){
                    result = A[i];
                    count = 1;
                }
            }
        }
        if(count > 1){
            count = 0;
        	for(int i = 0; i < n; i++){
                if(A[i] == result){
                    count++;
                }
            }
        }
        return count > n/2 ? result : -1;
    }
    ~~~
    
    **复杂度分析**:时间复杂度O(N)，空间复杂度O(1)
    
13. (2018统考真题)给定一个含n(n>=1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5,3,2,3}中未出现的最小正整数是1；数组{1,2,3}中未出现的最小正整数是4

    要求：

    <1>.给出算法的基本设计思想

    <2>.根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释

    <3>.说明所设计算法的时间复杂度和空间复杂度

    **思路**:由于本题只要求在时间上尽可能高效，因此采用空间换时间的思路。设计一个数组B，其长度为n，记录着1-n正整数出现的个数。遍历原数组A，对每个出现的正整数A\[i](应满足A[i]<=n，因为最小正整数必定介于[1,n+1])，令B[A[i]-1]++，最后遍历B，找到第一个B[j]=0的索引j，则未出现的最小正整数是j+1

    **代码**:

    ~~~c++
    int findMissMin(int A[], int n){
        int *B = new int[n];
        memset(B, 0, sizeof(int)*n);
        for(int i = 0; i < n; i++){
            if(A[i] > 0 && A[i] <= n){
                B[A[i]-1]++;
            }
        }
        for(int j = 0; j < n; j++){
            if(B[j] == 0) return j+1;
        }
        return n+1;
    }
    ~~~

    **复杂度分析**:时间复杂度O(N)，空间复杂度O(N)



### 2.3 线性表的链式表示(Page 40)

1. 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点。

   **思路**:用一个结点p表示待删除结点，当当前结点L的值为x时，p指向L，L移动到下一个结点，随后释放p。当前结点值不为x时，观察当前结点的下一个结点，当下一个结点不为空且值为x，则令p指向L->next，L指向L->next->next，随后释放p，并继续执行递归函数，直到移动到最后一个结点。

   **代码**:

   ~~~c++
   void Del_X_3(Linklist &L, ElemType x){
       if(L == NULL){
           return;
       }
       LNode * p;
       //当前结点的值就是x，删除该结点，移动到下一个结点
       if(L->data == x){
       	p = L;
           L = L->next;
           delete(p);
           Del_X_3(L, x);
       }
       else{
           //当前结点的下一个结点不为空，且值为x，删除当前结点的下一个结点
           if(L->next && L->next->data == x){
               p = L->next;
               L->next = L->next->next;
               delete(p);
           }
           Del_X_3(L->next, x);
       }
   }
   ~~~

   **注意**:我认为课本答案是错误的，因为其没有处理待删除结点的前后结点之间的关系

2. 在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法以实现上述操作。

   **思路**:遍历链表，由于是带头结点的元素，不用判断第一个结点就是x的情况，只需要判断：如果当前结点的下一个结点不为空且值为x时，用一个变量p指向当前结点的下一个结点，令当前结点指向下下个结点，并释放变量p。

   **代码**:

   ~~~c++
   void Del_X_1(Linklist &L, ElemType x){
       LNode *head = L;
       while(head){
           if(head->next && head->next->data == x){
               LNode *p = head->next;
               head->next = head->next->next;
               delete(p);
           }
           head = head->next;
       }
   }
   ~~~

3. 设L为带头结点的单链表，编写算法实现从尾到头反向输出每个节点的值。

   **思路**:用头插法把每个结点重新插入到头结点后，就能完成链表的逆置，然后遍历输出链表的值即可。

   **代码**:

   ~~~c++
   void R_Print(Linklist L){
       LNode *p = L->next;
       L->next = NULL;
       while(p){
           LNode *q = p;
           p = p->next;
           q->next = L->next;
           L->next = q;
       }
       p = L->next;
       while(p){
           printf(p->data);
           p = p->next;
       }
   }
   ~~~

4. 试编写在带头结点的单链表L中删除一个最小值结点的高效算法(假设最小值的结点是唯一的)。

   **思路**:遍历链表找到最小值结点的前驱节点，随后删除最小值结点

   **代码**:

   ~~~c++
   Linklist Delete_Min(Linklist &L){
       if(L->next == NULL){
           return L;
       }
       ElemType minnum = L->next->data;
       LNode *pre = L;
       LNode *cur = L;
       //查找最小值结点的前驱结点
       while(cur->next){
           if(cur->next->data < minnum){
           	minnum = cur->next->data;
               pre = cur;
           }
           cur = cur->next;
       }
       //删除最小值结点
       LNode *p = pre->next;
       pre->next = pre->next->next;
       delete(p);
       return L;
   }
   ~~~

5. 试编写算法将带头结点的单链表就地逆置，所谓“就地“就是辅助空间复杂度为O(1)。

   **思路**:这道题和第3题的思路一致，即：用头插法把每个结点重新插入到头结点

   **代码**:

   ~~~c++
   Linklist Reverse_1(Linklist &L){
       LNode *p = L->next;
       LNode *q;
       L->next = NULL;
       while(p){
           q = p;
           p = p->next;
           q->next = L->next;
           L->next = q;
       }
       return L;
   }
   ~~~

6. 有一个带头结点的单链表L，设计一个算法使其所有元素递增有序。

   **思路**:可以把链表的值存入数组，然后用归并或快排，随后再重新组建一个链表，这里不采用这个方式，而采用链式的插入排序。

   **代码**:

   ~~~c++
   void Sort(Linklist &L){
       if(L->next == NULL){
           return;
       }
       LNode *p = L->next;
       LNode *q;
       LNode *r
       L->next = NULL;
       while(p){
           if(p->next){
           	q = p->next;
           	p->next = p->next->next;
               //把q插入到排好序的链表中
               r = L;
               while(r->next && r->next->data < q->data){
                   r = r->next;
               }
               q->next = r->next;
               r->next = q;
           }
           p = p->next;
       }
   }
   ~~~

7. 设在一个带表头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表中所有介于给定的两个值(作为函数参数给出)之间的元素的元素(若存在)。

   **思路**:遍历链表，找到值介于给定两个值之间的元素的前驱，删除他们的后继元素即可

   **代码**:

   ~~~c++
   void RangeDelete(Linklist &L, int min, int max){
       LNode *pre = L;
       LNode *q;
       while(pre){
           if(pre->next && pre->next->data < max && pre->next->data > min){
               q = pre->next;
               pre->next = pre->next->next;
               delete(q);
           }
           pre = pre->next;
       }
   }
   ~~~

8. 给定两个单链表，编写算法找出两个链表的公共结点。

   <font color = red>**思路**</font>:公共结点的意思就是存在某个结点p，链表A和链表B都有p结点，且在p结点之后的结点均相同。解这道题可以用最简单的O(N<sup>2</sup>)的思路蛮算，但其实有更简单的方法。我们注意到：当两个链表拥有公共结点时，最后一个结点一定是一样的！但如果我们从各自的开头开始遍历，不一定能保证同时到达公共结点！因此想要同时到达公共起点，我们应该得到两个链表长度，并求出其差值diff，令较长的链表从diff开始，较短的链表从头结点开始遍历，这样能保证二者同时到达结尾，也就能保证同时遇到第一个公共结点啦。

   **代码**:

   ~~~c++
   Linklist Search_1st_Common(Linklist &L1, Linklist &L2){
       int length1 = 0, length2 = 0, diff;
       LNode *p1 = L1;
       LNode *p2 = L2;
       while(p1->next){
           length1++;
           p1 = p1->next;
       }
       while(p2->next){
           length2++;
           p2 = p2->next;
       }
       p1 = L1;
       p2 = L2;
    	if(length1 < length2){
           diff = length2 - length1;
           while(diff--){
               p2 = p2->next;
           }
       }   
       else{
           diff = length1 - length2;
           while(diff--){
   			p1 = p1->next;
           }
       }
       while(p1 && p2){
   		if(p1 == p2){
               return p1;
           }
           p1 = p1->next;
           p2 = p2->next;
       }
       return NULL;
   }
   ~~~

9. 给定一个带表头结点的单链表，设head为头指针，结点结构为(data,next)，data为整型元素，next为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间(要求：不允许使用数组作为辅助空间)

   **思路**:用链表的插入排序方式从小到大排序完后，再遍历链表输出元素并释放空间

   **代码**:

   ~~~c++
   void Min_Delete(Linklist &head){
       LNode *p = head;
       LNode *q;
       Lnode *r;
       while(p){
           if(p->next){
           	q = p->next;
           	p->next = p->next->next;
               r = head;
               while(r->next && r->next->data < q->data){
                   r = r->next;
               }
               q->next = r->next;
               r->next = q;
           }
           p = p->next;
       }
       p = head;
       while(p->next){
           print(p->next->data);
           q = p->next;
           p->next = p->next->next;
           delete(q);
       }
    	delete(head);   
   }
   ~~~

10. 将一个带头结点的单链表A分解为两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变。

    **思路**:设计一个计数器就可以了

    **代码**:

    ~~~c++
    Linklist DisCreat_1(Linklist &A){
        Linklist *B = new Linklist;
        B->next = NULL;
        int count = 1;
        LNode *p = A;
        LNode *b = B;
        LNode *q;
        while(p){
            if(p->next && count % 2 == 0){
                q = p->next;
                p->next = p->next->next;
                q->next = NULL;
                b->next = q;
                b = b->next;    
            }
            count++;
            p = p->next;
        }
        return B;
    }
    ~~~

11. 设C={a<sub>1</sub>,b<sub>1</sub>,a<sub>2</sub>,b<sub>2</sub>,...,a<sub>n</sub>,b<sub>n</sub>}为线性表，采用带头结点的hc单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A={a<sub>1</sub>,a<sub>2</sub>,...a<sub>n</sub>}，B={b<sub>n</sub>,b<sub>n-1</sub>,...,b<sub>1</sub>}。

    **思路**:这题和上面那题思路几乎一样，区别在于B表使用的是头插法

    **代码**:

    ~~~c++
    Linklist DisCreat_2(Linklist &A){
        Linklist *B = new Linklist;
        B->next = NULL;
        LNode *p = A;
        LNode *q;
        LNode *b = B;
        int count = 1;
        while(p){
            if(p->next && count % 2 == 0){
                q = p->next;
                p->next = p->next->next;
                q->next = b->next;
                b->next = q;
            }
            count++;
            p = p->next;
        }
        return B;
    }
    ~~~

12. 在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素，例如(7,10,10,21,30,42,42,42,51,70)将变成(7,10,21,30,42,51,70)。

    **思路**:

    **代码**:

13. 假设有两个按元素值递增次序排列的线性表，均以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值次序递减的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。

    **思路**:

    **代码**:

14. 设A和B是两个单链表(带头结点)，其中元素递增有序。设计一个算法从A和B中的公共元素产生单链表C，要求不破坏A、B的结点。

15. 已知两个链表A和B分别表示两个集合，其元素递增排列。编制函数，求A与B的交集，并存放于A链表中。