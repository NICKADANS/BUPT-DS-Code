# 数据结构(应用题及代码)

## 第2章 线性表

### 2.2 线性表的顺序表示(Page 19)

1. 从顺序表中删除具有最小值的元素(假设唯一)，并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。

   **思路**:步骤1.查找最小元素 步骤2.用最后一个元素填补删除的元素(除非删除的是最后一个元素)

   **代码**:

   ~~~ c++
   bool Del_Min(SqList &L, ElemType &value){
       if(L.length == 0)
           return false;
       int min_index = 0;
       value = L.data[0];
       for(int i = 1; i < L.length; i++){
   		if(L.data[i] < L.data[min_index]){
               min_index = i;
           	value = L.data[i];
           }
       }
       //这是一处我认为题目可能有bug的地方：当删除最后一个元素的时候，空出的位置不应该有元素填补
       if(min_index == L.length-1){
           L.data[min_index] = L.data[length];
       	return true;
       }
       L.data[min_index] = L.data[L.length-1];
       L.length--;
       return true;
   }
   ~~~

2. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)。

   **思路**:通过一个辅助变量temp来交换首尾两个元素，然后交换第二个和倒二个元素，然后交换第三个倒三个元素……以此类推

   **代码**:

   ~~~c++
   void Reverse(SqList &L){
       ElemType temp;
       for(int i = 0; i < L.length/2; i++){
           temp = L.data[i];
           L.data[i] = L.data[L.length-1-i];
           L.data[L.length-1-i] = temp;
       }
   }
   ~~~

3. 对长度为n的顺序表L，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。

   **思路**:用k记录顺序表L中不等于x的元素个数(即需要保存的元素个数)，边扫描边统计k，并将不等于x的元素挪动到第k个位置，最后修改L的长度

   **代码**:

   ~~~c++
   void del_x_1(SqList &L, ElemType x){
       int k = 0;
       for(int i = 0; i < L.length; i++){
           if(L.data[i] != x){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
   }
   ~~~

4. 从有序顺序表中删除其值在给定s与t之间(要求s<t)的所有元素，如果s或t不合理或顺序表为空，则显示出错信息并退出运行。

   **思路**:首先判断s与t是否合理或顺序表是否为空。观察到顺序表是“有序”的，可以用二分搜索找到第一个大于等于s的值的位置pos1以及第一个大于t的值的位置pos2，将pos2之后的值挪动到pos1之后，更新L的长度

   **代码**:

   ~~~c++
   bool Del_s_t2(SqList &L, ElemType s, ElemType t){
       if(s >= t || L.length == 0){
           return false;
       }
       int pos1 = -1, pos2 = L.length;
       //为了省事就不用二分搜索确定pos1和pos2了，直接用遍历确定
       for(int i = 0; i< L.length; i++){
           if(L.data[i] < s){
               pos1 = i;
           }
           if(L.data[i] > t){
               pos2 = i;
               break;
           }
       }
       pos1 += 1;//第一个大等于s的位置
       //用pos2及之后的值覆盖pos1到pos2-1之间的的值
       while(pos2 < L.length){
           L.data[pos1] = L.data[pos2];
           pos1++;
           pos2++;
       }
       L.length = pos1;
       return true;
   }
   ~~~

5. 从顺序表中删除其值在给定值s与t之间(包含s和t，要求s<t)的所有元素，如果s或t不合理或顺序表为空，则显示出错信息并退出运行

   **思路**:用k记录顺序表L中值不在s与t之间的元素个数(即需要保存的元素个数)，边扫描边统计k，令值不在s与t之间的元素挪动到第k个位置，最后修改L的长度

   **代码**:

   ~~~ c++
   bool Del_S_t(SqList &L, ElemType s, ElemType t){
       if(s >= t || L.length == 0){
           return false;
       }
       int k = 0;
       for(int i = 0; i < L.length; i++){
           if(L.data[i] < s || L.data[i] > t){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
       return true;
   }
   ~~~

6. 从有序顺序表中删除其值重复的元素，使表中所有的元素值均不同

   **思路**:由于数组是有序的，则重复的数必定连续出现，用k记录有序表中值不重复的元素个数，之后边扫描边统计k，当遇到的元素重复时，则跳过，否则将位于k位置的元素更新为当前元素，并增加k的值

   **代码**:

   ~~~c++
   void Delete_Same(SqList &L){
       if(L.length == 1){
           return;
       }
       int k = 1;
       for(int i = 1; i < L.length; i++){
           if(L.data[i] != L.data[k-1]){
               L.data[k] = L.data[i];
               k++;
           }
       }
       L.length = k;
   }
   ~~~

7. 将两个有序顺序表合成为一个新的有序顺序表，并由函数返回结果顺序表

   **思路**:假定两个顺序表是顺序递增的，使用两个指针i和j分别指向两个表的第一个元素，每次比较中挑选较小的元素放入新表，相应指针向前移动，当其中一根指针到达表的末端时，将另一张表的剩余元素都放入新表中。

   **代码**:

   ~~~c++
   bool Merge(SqList &A, SqList &B, SqList &C){
       if(A.length + B.length > C.maxSize){
           return false;
       }
       int i = 0, j = 0, k = 0;
       while(i < A.length && j < B.length){
           if(A[i] < B[j]){
               C[k++] = A[i++];
           }
           else{
               C[k++] = B[j++];
           }
       }
       while(i < A.length){
           C[k++] = A[i++];
       }
       while(j < B.length){
           C[k++] = B[j++];
       }
       C.length = A.length + B.length;
       return true;
   }
   ~~~

   



